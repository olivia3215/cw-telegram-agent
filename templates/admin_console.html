<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Console</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 8px;
            background-color: #f5f5f5;
            max-width: 100vw;
            overflow-x: hidden;
        }
        /* Ensure emojis render consistently regardless of formatting */
        strong, em {
            font-variant-emoji: emoji;
        }
        /* Prevent font-weight/font-style from affecting emoji rendering */
        strong em, em strong, strong, em {
            font-feature-settings: "liga" on, "calt" on;
        }
        .main-container {
            max-width: 100%;
            width: 100%;
            box-sizing: border-box;
        }
        body.auth-locked {
            overflow: hidden;
        }
        .auth-overlay {
            position: fixed;
            inset: 0;
            background: rgba(44, 62, 80, 0.92);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            z-index: 1000;
        }
        .auth-overlay.hidden {
            display: none;
        }
        .auth-card {
            background: #ffffff;
            border-radius: 8px;
            padding: 32px;
            width: 100%;
            max-width: 420px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            text-align: center;
        }
        .auth-card h2 {
            margin-top: 0;
            color: #2c3e50;
        }
        .auth-card p {
            font-size: 14px;
            color: #4a5765;
            margin-bottom: 16px;
        }
        .auth-actions {
            margin: 16px 0 8px 0;
        }
        .auth-actions button {
            padding: 10px 18px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #007bff;
            color: #ffffff;
        }
        .auth-actions button:disabled {
            background: #9bb8e4;
            cursor: not-allowed;
        }
        .auth-code-entry {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        .auth-code-entry input {
            flex: 1;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccd2da;
            border-radius: 4px;
            text-align: center;
            letter-spacing: 4px;
        }
        .auth-code-entry button {
            padding: 10px 16px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #28a745;
            color: #ffffff;
        }
        .auth-code-entry button:disabled {
            background: #8dd3a4;
            cursor: not-allowed;
        }
        .auth-message {
            font-size: 14px;
            margin-top: 12px;
        }
        .auth-message.error {
            color: #c0392b;
        }
        .auth-message.info {
            color: #2c3e50;
        }
        .auth-message.hidden {
            display: none;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 12px 0;
            margin-bottom: 16px;
            border-radius: 4px;
        }
        .header h1 {
            margin: 0;
            font-size: 24px;
        }
        .tab-bar {
            display: flex !important;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
            visibility: visible !important;
            opacity: 1 !important;
        }
        /* Ensure subtab bars inside tab panels are always visible when panel is active */
        .tab-panel.active .tab-bar {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        /* Ensure subtab buttons are visible */
        .tab-panel.active .tab-bar .tab-button {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        .tab-button {
            border: none;
            background: #e0e6ed;
            color: #2c3e50;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s ease, color 0.2s ease;
        }
        .tab-button.active {
            background: #2c3e50;
            color: #fff;
        }
        .tab-button:hover {
            background: #cfd8e3;
        }
        .tab-panel {
            display: none;
        }
        .tab-panel.active {
            display: block;
        }
        /* Ensure subtab bars are visible when their parent tab panel is active */
        .tab-panel.active .tab-bar {
            display: flex;
        }
        .subtab-panel {
            display: none;
        }
        .subtab-panel.active {
            display: block;
        }
        
        /* Agent Parameters styling */
        .agent-param-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 24px;
            margin-bottom: 24px;
        }
        .agent-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid #eee;
            flex-wrap: wrap;
            gap: 16px;
        }
        .agent-status-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }
        .agent-status-info {
            text-align: right;
            min-width: 150px;
        }
        @media (max-width: 600px) {
            .agent-status-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .agent-status-info {
                text-align: left;
                width: 100%;
                border-top: 1px solid #f0f0f0;
                padding-top: 8px;
            }
            .agent-param-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }
        }
        .agent-param-section {
            margin-bottom: 24px;
        }
        .agent-param-section h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 16px;
            color: #2c3e50;
        }
        .role-prompt-tag {
            display: flex;
            align-items: center;
            background: #f0f2f5;
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 14px;
        }
        .role-prompt-tag button {
            background: none;
            border: none;
            color: #dc3545;
            cursor: pointer;
            font-weight: bold;
            padding: 0 4px;
            margin-left: 8px;
        }
        .agent-param-textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
        }
        .agent-param-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        .agent-param-checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
        }
        .agent-param-checkbox-label input {
            margin-right: 8px;
        }
        .role-prompts-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
        }
        .placeholder-card {
            background: white;
            border-radius: 8px;
            padding: 40px;
            border: 1px dashed #c3c8d1;
            color: #6c757d;
            font-size: 16px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .controls {
            padding: 12px 0;
            margin-bottom: 16px;
        }
        .directory-selector {
            margin-bottom: 12px;
        }
        .directory-selector select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            min-width: 300px;
        }
        .import-section {
            padding: 10px 0;
            margin-bottom: 12px;
        }
        .import-section input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
        }
        .import-section button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .import-section button:hover {
            background: #0056b3;
        }
        .media-grid {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 0;
            margin-bottom: 16px;
            width: 100%;
        }
        @media (max-width: 600px) {
            .directory-selector select {
                min-width: 0;
                width: 100%;
            }
            .import-section input {
                width: 100%;
                margin-right: 0;
                margin-bottom: 8px;
            }
            .import-section button {
                width: 100%;
            }
            .auth-card {
                padding: 20px;
                max-width: 90%;
            }
            .header h1 {
                font-size: 20px;
            }
            .tab-button {
                padding: 6px 12px;
                font-size: 13px;
            }
        }
        .media-item {
            display: flex;
            flex-direction: row;
            gap: 12px;
            margin-bottom: 16px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        @media (max-width: 768px) {
            .media-item {
                flex-direction: column;
            }
            .media-preview {
                flex: none;
                max-width: 100%;
            }
        }
        .media-preview {
            flex: 0 0 50%;
            max-width: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .media-preview img {
            width: 100%;
            height: auto;
            display: block;
        }
        .media-preview video {
            width: 100%;
            height: auto;
            object-fit: contain;
        }
        .media-preview audio {
            width: 100%;
            height: auto;
            min-height: 48px;
            display: block;
        }
        .media-info {
            flex: 1;
            padding: 8px 0;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        .media-info h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
        }
        .media-info p {
            margin: 5px 0;
            font-size: 14px;
            color: #666;
        }
        .description-edit {
            margin-top: 10px;
        }
        .description-edit textarea {
            width: 100%;
            min-height: 180px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            resize: vertical;
            background: #fafafa;
            box-sizing: border-box;
        }
        .description-edit button {
            margin-top: 8px;
            padding: 6px 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .description-edit button:hover {
            background: #1e7e34;
        }
        .error {
            color: #dc3545;
            font-size: 12px;
            margin-top: 5px;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .tgs-animation-container {
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            overflow: hidden;
        }
        .tgs-animation-container svg {
            max-width: 100%;
            max-height: 100%;
        }
    </style>
</head>
<body>
    <div id="auth-overlay" class="auth-overlay hidden" role="dialog" aria-modal="true">
        <div class="auth-card">
            <h2>Verify Access</h2>
            <p>Request a login code sent to the puppet master Telegram account to enable the admin console.</p>
            <div id="auth-error" class="auth-message error hidden" role="alert"></div>
            <div id="auth-status" class="auth-message info hidden"></div>
            <div class="auth-actions">
                <button id="request-code-btn">Send verification code</button>
            </div>
            <div class="auth-code-entry">
                <input id="otp-input" type="text" inputmode="numeric" autocomplete="one-time-code" maxlength="6" placeholder="123456" aria-label="Six digit code">
                <button id="verify-code-btn">Verify</button>
            </div>
        </div>
    </div>
    <div class="header">
        <h1>Admin Console</h1>
    </div>

    <nav class="tab-bar">
        <button class="tab-button active" data-tab="global">Global</button>
        <button class="tab-button" data-tab="agents">Agents</button>
        <button class="tab-button" data-tab="conversations">Conversations</button>
    </nav>

    <div id="tab-panels">
        <!-- Global Tab -->
        <section class="tab-panel active" data-tab-panel="global">
            <nav class="tab-bar" style="margin-bottom: 16px;">
                <button class="tab-button active" data-subtab="media">Media Editor</button>
                <button class="tab-button" data-subtab="documents-global">Documents</button>
                <button class="tab-button" data-subtab="role-prompts">Role Prompts</button>
                <button class="tab-button" data-subtab="parameters-global">Parameters</button>
            </nav>
            <div id="global-container" class="main-container">
                <!-- Media Editor Subtab -->
                <div class="subtab-panel active" data-subtab-panel="media">
                    <div class="controls">
                        <div class="directory-selector">
                            <label for="directory-select">Select Media Directory:</label><br>
                            <select id="directory-select">
                                <option value="">Choose a directory...</option>
                            </select>
                        </div>

                        <div class="directory-selector" id="media-limit-container" style="display: none; margin-top: 12px;">
                            <label for="media-limit">Limit to most recent media (leave empty for all):</label><br>
                            <input type="number" id="media-limit" min="1" placeholder="e.g., 100" style="width: 200px; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        </div>

                        <div class="import-section">
                            <h3>Import Sticker Set</h3>
                            <input type="text" id="sticker-set-name" placeholder="Sticker set name (e.g., WendyDancer)">
                            <button onclick="importStickerSet()">Import Set</button>
                            <div id="import-status"></div>
                        </div>
                    </div>

                    <div class="main-container">
                        <div id="pagination-top" style="display: none; margin-bottom: 16px; padding: 12px; background: white; border-radius: 4px; flex-wrap: wrap; align-items: center; justify-content: space-between; gap: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 12px;">
                                <button onclick="previousPage()" id="prev-btn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">← Previous</button>
                                <select id="page-select" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; min-width: 140px;">
                                    <option value="">Go to page…</option>
                                </select>
                                <button onclick="nextPage()" id="next-btn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Next →</button>
                            </div>
                            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px;">
                                <select id="sticker-set-select" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; min-width: 220px;">
                                    <option value="">Jump to…</option>
                                </select>
                            </div>
                        </div>

                        <div id="media-container">
                            <div class="loading">Select a directory to view media files</div>
                        </div>

                        <div id="pagination-bottom" style="display: none; margin-top: 16px; padding: 12px; background: white; border-radius: 4px; flex-wrap: wrap; align-items: center; justify-content: space-between; gap: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 12px;">
                                <button onclick="previousPage()" id="prev-btn-bottom" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">← Previous</button>
                                <select id="page-select-bottom" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; min-width: 140px;">
                                    <option value="">Go to page…</option>
                                </select>
                                <button onclick="nextPage()" id="next-btn-bottom" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Next →</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Documents Subtab (Global) -->
                <div class="subtab-panel" data-subtab-panel="documents-global">
                    <div class="controls">
                        <div class="directory-selector">
                            <label for="global-docs-config-select">Select Config Directory:</label><br>
                            <select id="global-docs-config-select">
                                <option value="">Choose a config directory...</option>
                            </select>
                        </div>
                        <div class="directory-selector" style="margin-top: 12px;">
                            <label for="global-docs-select">Select Document:</label><br>
                            <select id="global-docs-select">
                                <option value="">Choose a document...</option>
                            </select>
                        </div>
                        <div style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="createGlobalDoc()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Create New Document</button>
                            <button onclick="deleteGlobalDoc()" id="delete-global-doc-btn" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">Delete Document</button>
                        </div>
                    </div>
                    <div class="main-container" style="margin-top: 16px;">
                        <div id="global-docs-editor-container">
                            <div class="loading">Select a config directory and document to edit</div>
                        </div>
                    </div>
                </div>
                
                <!-- Role Prompts Subtab (Global) -->
                <div class="subtab-panel" data-subtab-panel="role-prompts">
                    <div class="controls">
                        <div class="directory-selector">
                            <label for="global-prompts-config-select">Select Config Directory:</label><br>
                            <select id="global-prompts-config-select">
                                <option value="">Choose a config directory...</option>
                            </select>
                        </div>
                        <div class="directory-selector" style="margin-top: 12px;">
                            <label for="global-prompts-select">Select Role Prompt:</label><br>
                            <select id="global-prompts-select">
                                <option value="">Choose a role prompt...</option>
                            </select>
                        </div>
                        <div style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="createGlobalPrompt()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Create New Role Prompt</button>
                            <button onclick="deleteGlobalPrompt()" id="delete-global-prompt-btn" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">Delete Role Prompt</button>
                        </div>
                    </div>
                    <div class="main-container" style="margin-top: 16px;">
                        <div id="global-prompts-editor-container">
                            <div class="loading">Select a config directory and role prompt to edit</div>
                        </div>
                    </div>
                </div>
                
                <!-- Parameters Subtab (Global) -->
                <div class="subtab-panel" data-subtab-panel="parameters-global">
                    <div class="main-container" style="margin-top: 16px;">
                        <div id="global-parameters-container">
                            <div class="loading">Loading parameters...</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Agents Tab -->
        <section class="tab-panel" data-tab-panel="agents">
            <nav class="tab-bar" style="margin-bottom: 16px;">
                <button class="tab-button active" data-subtab="profile">Profile</button>
                <button class="tab-button" data-subtab="parameters">Parameters</button>
                <button class="tab-button" data-subtab="memories">Memories</button>
                <button class="tab-button" data-subtab="intentions">Intentions</button>
                <button class="tab-button" data-subtab="documents-agent">Documents</button>
                <button class="tab-button" data-subtab="memberships">Memberships</button>
            </nav>
            <div class="controls">
                <div class="directory-selector">
                    <label for="agents-agent-select">Select Agent:</label><br>
                    <select id="agents-agent-select">
                        <option value="">Choose an agent...</option>
                    </select>
                </div>
            </div>
            <div id="agents-container" class="main-container">
                <!-- Profile Subtab -->
                <div class="subtab-panel active" data-subtab-panel="profile">
                    <!-- Agent Profile Section -->
                    <div id="agent-profile-section" style="display: none; margin-bottom: 24px; padding: 20px; background: #ffffff; border: 1px solid #e0e0e0; border-radius: 8px;">
                        <h3 style="margin-top: 0; margin-bottom: 20px; font-size: 18px; color: #2c3e50;">Agent Profile</h3>
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 20px; align-items: start;">
                            <!-- Profile Photo -->
                            <div style="text-align: center;">
                                <img id="agent-profile-photo" src="" alt="Profile Photo" style="width: 100px; height: 100px; border-radius: 50%; border: 2px solid #e0e0e0; cursor: pointer; object-fit: cover; background: #f5f5f5;" onclick="showProfilePhotoFullscreen()">
                                <div style="margin-top: 8px; font-size: 12px; color: #666;">Click to enlarge</div>
                            </div>
                            <!-- Profile Photo Fullscreen Modal -->
                            <div id="profile-photo-modal" style="display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); cursor: pointer;" onclick="closeProfilePhotoFullscreen()">
                                <img id="profile-photo-fullscreen" src="" alt="Profile Photo" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 90%; max-height: 90%; border-radius: 8px;">
                            </div>
                            <!-- Profile Fields -->
                            <div style="display: grid; gap: 16px;">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                    <div>
                                        <label for="agent-profile-first-name" style="display: block; margin-bottom: 4px; font-weight: 500; color: #2c3e50;">First Name:</label>
                                        <input type="text" id="agent-profile-first-name" style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                    </div>
                                    <div>
                                        <label for="agent-profile-last-name" style="display: block; margin-bottom: 4px; font-weight: 500; color: #2c3e50;">Last Name:</label>
                                        <input type="text" id="agent-profile-last-name" style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                    </div>
                                </div>
                                <div>
                                    <label for="agent-profile-username" style="display: block; margin-bottom: 4px; font-weight: 500; color: #2c3e50;">Username:</label>
                                    <input type="text" id="agent-profile-username" placeholder="@username" style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                </div>
                                <div>
                                    <label for="agent-profile-telegram-id" style="display: block; margin-bottom: 4px; font-weight: 500; color: #2c3e50;">Telegram ID:</label>
                                    <input type="text" id="agent-profile-telegram-id" readonly style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: #f5f5f5; color: #666;">
                                </div>
                                <div>
                                    <label for="agent-profile-bio" style="display: block; margin-bottom: 4px; font-weight: 500; color: #2c3e50;">Bio:</label>
                                    <textarea id="agent-profile-bio" rows="3" style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; font-family: inherit; resize: vertical;" oninput="validateBio()"></textarea>
                                    <div id="agent-profile-bio-status" style="margin-top: 4px; font-size: 12px;"></div>
                                </div>
                                <div>
                                    <label for="agent-profile-birthday" style="display: block; margin-bottom: 4px; font-weight: 500; color: #2c3e50;">Birthday:</label>
                                    <div style="display: grid; grid-template-columns: auto auto auto; gap: 8px; align-items: center;">
                                        <select id="agent-profile-birthday-month" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                            <option value="">Month</option>
                                            <option value="1">January</option>
                                            <option value="2">February</option>
                                            <option value="3">March</option>
                                            <option value="4">April</option>
                                            <option value="5">May</option>
                                            <option value="6">June</option>
                                            <option value="7">July</option>
                                            <option value="8">August</option>
                                            <option value="9">September</option>
                                            <option value="10">October</option>
                                            <option value="11">November</option>
                                            <option value="12">December</option>
                                        </select>
                                        <select id="agent-profile-birthday-day" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                            <option value="">Day</option>
                                        </select>
                                        <input type="number" id="agent-profile-birthday-year" placeholder="Year (optional)" min="1900" max="2100" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                    </div>
                                </div>
                                <div style="display: flex; gap: 8px; margin-top: 8px;">
                                    <button onclick="saveAgentProfile()" id="agent-profile-save-btn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Save Profile</button>
                                    <button onclick="cancelAgentProfileEdit()" id="agent-profile-cancel-btn" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; display: none;">Cancel</button>
                                    <div id="agent-profile-save-status" style="margin-left: 8px; line-height: 32px; font-size: 14px;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="profile-container">
                        <div class="loading">Select an agent to view profile</div>
                    </div>
                </div>
                <div class="subtab-panel" data-subtab-panel="parameters">
                    <div id="parameters-container">
                        <div class="loading">Select an agent to configure</div>
                    </div>
                </div>
                <div class="subtab-panel" data-subtab-panel="memories">
                    <div id="memories-container">
                        <div class="loading">Select an agent to view memories</div>
                    </div>
                </div>
                <div class="subtab-panel" data-subtab-panel="intentions">
                    <div id="intentions-container">
                        <div class="loading">Select an agent to view intentions</div>
                    </div>
                </div>
                <div class="subtab-panel" data-subtab-panel="documents-agent">
                    <div class="controls">
                        <div class="directory-selector">
                            <label for="agent-docs-select">Select Document:</label><br>
                            <select id="agent-docs-select">
                                <option value="">Choose a document...</option>
                            </select>
                        </div>
                        <div style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="createAgentDoc()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Create New Document</button>
                            <button onclick="deleteAgentDoc()" id="delete-agent-doc-btn" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">Delete Document</button>
                        </div>
                    </div>
                    <div class="main-container" style="margin-top: 16px;">
                        <div id="agent-docs-editor-container">
                            <div class="loading">Select an agent and document to edit</div>
                        </div>
                    </div>
                </div>
                <div class="subtab-panel" data-subtab-panel="memberships">
                    <div id="memberships-container">
                        <div class="loading">Select an agent to manage memberships</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Conversations Tab -->
        <section class="tab-panel" data-tab-panel="conversations">
            <nav class="tab-bar" style="margin-bottom: 16px;">
                <button class="tab-button active" data-subtab="notes-conv">Notes</button>
                <button class="tab-button" data-subtab="conversation-llm">Conversation LLM</button>
                <button class="tab-button" data-subtab="plans">Plans</button>
                <button class="tab-button" data-subtab="conversation">Conversation</button>
                <button class="tab-button" data-subtab="xsend">XSend</button>
            </nav>
            <div class="controls">
                <div class="directory-selector" style="margin-bottom: 16px;">
                    <label for="recent-conversations-select">Recent Conversations:</label><br>
                    <select id="recent-conversations-select">
                        <option value="">Select a recent conversation...</option>
                    </select>
                </div>
                <div class="directory-selector">
                    <label for="conversations-agent-select">Select Agent:</label><br>
                    <select id="conversations-agent-select">
                        <option value="">Choose an agent...</option>
                    </select>
                </div>
                <div class="directory-selector" style="margin-top: 16px;">
                    <label for="conversations-partner-select">Select Conversation:</label><br>
                    <select id="conversations-partner-select">
                        <option value="">Select Conversation</option>
                    </select>
                    <input type="text" id="conversations-user-id" placeholder="Or type user ID, username, or phone number (e.g., 123456789, @lambda_n, +1234567890)" style="margin-top: 8px; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 300px;">
                    <button onclick="loadConversationData()" style="margin-top: 8px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Load</button>
                </div>
            </div>
            <div id="conversations-container" class="main-container">
                <div class="subtab-panel active" data-subtab-panel="notes-conv">
                    <div id="notes-conv-container">
                        <div class="loading">Select an agent and conversation partner</div>
                    </div>
                </div>
                <div class="subtab-panel" data-subtab-panel="conversation-llm">
                    <div id="conversation-llm-container">
                        <div class="loading">Select an agent and conversation partner</div>
                    </div>
                </div>
                <div class="subtab-panel" data-subtab-panel="plans">
                    <div id="plans-container">
                    </div>
                </div>
                <div class="subtab-panel" data-subtab-panel="conversation">
                    <div id="conversation-container">
                        <div class="loading">Select an agent and conversation partner</div>
                    </div>
                </div>
                <div class="subtab-panel" data-subtab-panel="xsend">
                    <div id="xsend-container">
                        <div class="loading">Select an agent and conversation partner</div>
                        <div style="margin-top: 16px; display: none;" id="xsend-content">
                            <div class="directory-selector">
                                <label for="xsend-intent-textarea">Intent:</label><br>
                                <textarea id="xsend-intent-textarea" placeholder="Enter the intent message..." style="width: 100%; min-height: 150px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; resize: vertical; box-sizing: border-box;"></textarea>
                            </div>
                            <div style="margin-top: 16px;">
                                <button onclick="sendXSend()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">XSend</button>
                                <div id="xsend-status" style="margin-top: 8px; font-size: 14px;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>


    </div>
    <script>
        let currentDirectory = '';
        let autoSaveTimers = {}; // Track auto-save timers for each textarea
        let savingStates = {}; // Track saving state for each textarea
        let currentPage = 1;
        let itemsPerPage = 10;
        let allMediaFiles = []; // Store all media files for pagination
        let currentTotalPages = 1;
        let stickerSetStartIndexMap = {};
        let stickerSetOrder = [];
        let stickerSetFirstMediaMap = {};
        let pendingScrollToMediaId = null;
        const API_BASE = '/admin/api';
        let appInitialized = false;
        let requestCooldownTimer = null;
        const DEFAULT_COOLDOWN_SECONDS = 30;

        const authOverlay = document.getElementById('auth-overlay');
        const authStatusEl = document.getElementById('auth-status');
        const authErrorEl = document.getElementById('auth-error');
        const requestCodeBtn = document.getElementById('request-code-btn');
        const verifyCodeBtn = document.getElementById('verify-code-btn');
        const otpInput = document.getElementById('otp-input');
        const initialRequestButtonLabel = requestCodeBtn ? requestCodeBtn.textContent : 'Send verification code';

        requestCodeBtn?.addEventListener('click', requestVerificationCode);
        verifyCodeBtn?.addEventListener('click', verifyVerificationCode);
        otpInput?.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') {
                verifyVerificationCode();
            }
        });

        checkAuthStatus();

        function initializeApp() {
            if (appInitialized) {
                return;
            }
            appInitialized = true;
            hideAuthOverlay();

            // Don't add old event listeners - we use event delegation now
            // The event delegation is set up below in the script

            const directorySelect = document.getElementById('directory-select');
            const mediaLimitContainer = document.getElementById('media-limit-container');
            const mediaLimitInput = document.getElementById('media-limit');
            
            if (directorySelect) {
                directorySelect.addEventListener('change', (event) => {
                    currentDirectory = event.target.value;
                    if (currentDirectory) {
                        // Show limit field only for state/media directory
                        const isStateMedia = currentDirectory.includes('state/media') || currentDirectory.endsWith('state/media');
                        if (mediaLimitContainer) {
                            mediaLimitContainer.style.display = isStateMedia ? 'block' : 'none';
                        }
                        if (mediaLimitInput && !isStateMedia) {
                            mediaLimitInput.value = ''; // Clear limit when switching away from state/media
                        }
                        loadMediaFiles(currentDirectory);
                    } else {
                        // Clear everything when directory is deselected
                        allMediaFiles = [];
                        currentPage = 1;
                        document.getElementById('media-container').innerHTML =
                            '<div class="loading">Select a directory to view media files</div>';
                        // Hide pagination controls
                        document.getElementById('pagination-top').style.display = 'none';
                        document.getElementById('pagination-bottom').style.display = 'none';
                        updatePaginationControls(0);
                        populatePageSelect(0);
                        populateStickerSetSelect();
                        // Hide limit field
                        if (mediaLimitContainer) {
                            mediaLimitContainer.style.display = 'none';
                        }
                        if (mediaLimitInput) {
                            mediaLimitInput.value = '';
                        }
                    }
                });

                fetchDirectories(directorySelect);
            }
            
            // Add event listener to limit field to reload media when it changes
            if (mediaLimitInput) {
                let limitTimeout;
                mediaLimitInput.addEventListener('input', () => {
                    // Debounce the reload to avoid excessive API calls
                    clearTimeout(limitTimeout);
                    limitTimeout = setTimeout(() => {
                        if (currentDirectory) {
                            loadMediaFiles(currentDirectory);
                        }
                    }, 500); // Wait 500ms after user stops typing
                });
            }

            setupPaginationControls();
            
            // Ensure pagination is hidden initially (no directory selected)
            document.getElementById('pagination-top').style.display = 'none';
            document.getElementById('pagination-bottom').style.display = 'none';
        }

        function fetchDirectories(selectElement) {
            fetchWithAuth(`${API_BASE}/directories`)
                .then((response) => response.json())
                .then((directories) => {
                    directories.forEach((dir) => {
                        const option = document.createElement('option');
                        option.value = dir.path;
                        option.textContent = dir.name;
                        selectElement.appendChild(option);
                    });
                })
                .catch((error) => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    console.error('Failed to load directories', error);
                });
        }

        function fetchWithAuth(url, options = {}) {
            // Always add cache: 'no-store' to prevent browser caching
            // This ensures fresh data for all requests
            // Put defaults AFTER options so they overwrite any cache settings from caller
            const finalOptions = Object.assign({}, options, {
                credentials: 'same-origin',
                cache: 'no-store'
            });
            return fetch(url, finalOptions).then((response) => {
                if (response.status === 401) {
                    handleUnauthorized();
                }
                return response;
            });
        }

        function handleUnauthorized(message) {
            showAuthOverlay(message || 'Session expired. Please verify again.');
            throw new Error('unauthorized');
        }

        function showAuthOverlay(message) {
            clearRequestCooldown();
            if (typeof message === 'string') {
                showAuthStatus(message);
            } else {
                showAuthStatus('');
            }
            showAuthError('');
            authOverlay?.classList.remove('hidden');
            document.body.classList.add('auth-locked');
            if (otpInput) {
                otpInput.value = '';
                window.setTimeout(() => otpInput.focus(), 0);
            }
        }

        function hideAuthOverlay() {
            authOverlay?.classList.add('hidden');
            document.body.classList.remove('auth-locked');
            showAuthStatus('');
            showAuthError('');
            clearRequestCooldown();
        }

        function showAuthStatus(message) {
            if (!authStatusEl) {
                return;
            }
            authStatusEl.textContent = message || '';
            authStatusEl.classList.toggle('hidden', !message);
        }

        function showAuthError(message) {
            if (!authErrorEl) {
                return;
            }
            authErrorEl.textContent = message || '';
            authErrorEl.classList.toggle('hidden', !message);
        }

        function clearRequestCooldown() {
            if (requestCooldownTimer) {
                clearInterval(requestCooldownTimer);
                requestCooldownTimer = null;
            }
            if (requestCodeBtn) {
                requestCodeBtn.disabled = false;
                requestCodeBtn.textContent = initialRequestButtonLabel;
            }
        }

        function setRequestCooldown(seconds) {
            if (!requestCodeBtn) {
                return;
            }
            clearRequestCooldown();
            let remaining = Math.max(Math.floor(seconds), 0);
            if (remaining <= 0) {
                return;
            }
            requestCodeBtn.disabled = true;
            requestCodeBtn.textContent = `Resend code (${remaining}s)`;
            requestCooldownTimer = window.setInterval(() => {
                remaining -= 1;
                if (remaining <= 0) {
                    clearRequestCooldown();
                    showAuthStatus('You can request a new code if needed.');
                } else {
                    requestCodeBtn.textContent = `Resend code (${remaining}s)`;
                }
            }, 1000);
        }

        async function requestVerificationCode() {
            if (!requestCodeBtn) {
                return;
            }
            showAuthError('');
            showAuthStatus('Sending verification code...');
            requestCodeBtn.disabled = true;

            try {
                const response = await fetchWithAuth(`${API_BASE}/auth/request-code`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: '{}',
                });
                const result = await response.json();
                if (response.status === 200 && result.success) {
                    const expiresIn = typeof result.expires_in === 'number' ? result.expires_in : 0;
                    const expireMinutes = Math.max(Math.round(expiresIn / 60) || 1, 1);
                    showAuthStatus(`Verification code sent. It expires in ${expireMinutes} minute${expireMinutes === 1 ? '' : 's'}.`);
                    const cooldown = typeof result.cooldown === 'number' ? result.cooldown : DEFAULT_COOLDOWN_SECONDS;
                    setRequestCooldown(cooldown);
                    return;
                }
                if (response.status === 429 && result.retry_after) {
                    showAuthError(result.error || 'Please wait before requesting a new code.');
                    setRequestCooldown(result.retry_after);
                    return;
                }
                showAuthError(result.error || 'Failed to send verification code.');
                showAuthStatus('');
            } catch (error) {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                showAuthError(`Failed to send verification code: ${error.message || error}`);
                showAuthStatus('');
            } finally {
                if (!requestCooldownTimer && requestCodeBtn) {
                    requestCodeBtn.disabled = false;
                    requestCodeBtn.textContent = initialRequestButtonLabel;
                }
            }
        }

        async function verifyVerificationCode() {
            if (!verifyCodeBtn) {
                return;
            }
            const code = (otpInput?.value || '').trim();
            if (!/^\d{6}$/.test(code)) {
                showAuthError('Enter the six digit verification code.');
                return;
            }

            showAuthError('');
            showAuthStatus('Verifying code...');
            verifyCodeBtn.disabled = true;

            try {
                const response = await fetchWithAuth(`${API_BASE}/auth/verify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code }),
                });
                const result = await response.json();
                if (response.status === 200 && result.success) {
                    showAuthStatus('Verification successful.');
                    clearRequestCooldown();
                    if (otpInput) {
                        otpInput.value = '';
                    }
                    hideAuthOverlay();
                    initializeApp();
                    return;
                }
                if (result.already_verified) {
                    hideAuthOverlay();
                    initializeApp();
                    return;
                }
                showAuthError(result.error || 'Verification failed.');
                if (typeof result.remaining_attempts === 'number') {
                    showAuthStatus(`Attempts remaining: ${result.remaining_attempts}`);
                } else {
                    showAuthStatus('');
                }
            } catch (error) {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                showAuthError(`Verification failed: ${error.message || error}`);
                showAuthStatus('');
            } finally {
                verifyCodeBtn.disabled = false;
            }
        }

        function checkAuthStatus() {
            fetchWithAuth(`${API_BASE}/auth/status`)
                .then((response) => response.json())
                .then((data) => {
                    if (data.verified) {
                        initializeApp();
                    } else {
                        showAuthOverlay('Request a verification code to continue.');
                    }
                })
                .catch((error) => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    showAuthError('Unable to reach the server. Try again in a moment.');
                    showAuthOverlay();
                });
        }

        function loadMediaFiles(directoryPath, preservePage = false) {
            document.getElementById('media-container').innerHTML =
                '<div class="loading">Loading media files...</div>';

            const savedPage = currentPage; // Save current page

            const encodedPath = encodeURIComponent(directoryPath);
            // Get limit value if set
            const mediaLimitInput = document.getElementById('media-limit');
            const limit = mediaLimitInput && mediaLimitInput.value.trim() ? mediaLimitInput.value.trim() : '';
            const limitParam = limit ? `&limit=${encodeURIComponent(limit)}` : '';
            fetchWithAuth(`${API_BASE}/media?directory=${encodedPath}${limitParam}`)
                .then(response => response.json())
                .then(data => {
                        if (data.error) {
                            document.getElementById('media-container').innerHTML =
                                `<div class="error">Error: ${escapeHtml(data.error)}</div>`;
                            return;
                        }

                    // Flatten the grouped media into a single array
                    allMediaFiles = [];
                    pendingScrollToMediaId = null;
                    stickerSetStartIndexMap = {};
                    stickerSetOrder = [];
                    stickerSetFirstMediaMap = {};
                    let globalIndex = 0;

                    // Track display names for each sticker set
                    const stickerSetDisplayNames = {};
                    const stickerSetTypes = {}; // Track if set is emoji or sticker
                    
                    for (const [stickerSet, mediaFiles] of Object.entries(data.grouped_media)) {
                        if (!Array.isArray(mediaFiles) || mediaFiles.length === 0) {
                            continue;
                        }

                        // Determine display name for this set (use first media item's title if available)
                        let displayName = stickerSet;
                        const firstMedia = mediaFiles[0];
                        if (firstMedia && firstMedia.sticker_set_title && firstMedia.sticker_set_title !== stickerSet) {
                            displayName = `${stickerSet} (${firstMedia.sticker_set_title})`;
                        }
                        
                        // Check if this is an emoji set
                        const isEmojiSet = firstMedia && firstMedia.is_emoji_set;
                        stickerSetTypes[stickerSet] = isEmojiSet;
                        
                        // Add prefix to distinguish emoji sets from sticker sets
                        if (isEmojiSet) {
                            displayName = `🎨 Emoji Set: ${displayName}`;
                        } else if (stickerSet !== "Other Media" && !stickerSet.startsWith("Other Media -")) {
                            displayName = `📎 Sticker Set: ${displayName}`;
                        }
                        
                        stickerSetDisplayNames[stickerSet] = displayName;

                        stickerSetStartIndexMap[stickerSet] = globalIndex;
                        stickerSetOrder.push(stickerSet);
                        stickerSetFirstMediaMap[stickerSet] = mediaFiles[0]?.unique_id || null;

                        mediaFiles.forEach(media => {
                            // Store the base display name (without prefix) for section headers
                            let baseDisplayName = stickerSet;
                            if (media.sticker_set_title && media.sticker_set_title !== stickerSet) {
                                baseDisplayName = `${stickerSet} (${media.sticker_set_title})`;
                            }
                            media.sticker_set_display = baseDisplayName;
                            media.sticker_set_display_with_prefix = displayName;
                            media.is_emoji_set = isEmojiSet;
                            allMediaFiles.push(media);
                            globalIndex += 1;
                        });
                    }
                    
                    // Store display names and types for use in dropdown
                    window.stickerSetDisplayNames = stickerSetDisplayNames;
                    window.stickerSetTypes = stickerSetTypes;

                    // Reset to page 1 unless preservePage is true
                    if (!preservePage) {
                        currentPage = 1;
                    } else {
                        // Restore the saved page, but ensure it's within bounds
                        const totalPages = Math.ceil(allMediaFiles.length / itemsPerPage);
                        currentPage = Math.min(savedPage, Math.max(1, totalPages));
                    }
                    displayCurrentPage();
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    document.getElementById('media-container').innerHTML =
                        `<div class="error">Error loading media files: ${escapeHtml(String(error))}</div>`;
                });
        }

        function displayCurrentPage() {
            const container = document.getElementById('media-container');

            // If no directory is selected, don't display anything
            if (!currentDirectory) {
                container.innerHTML = '<div class="loading">Select a directory to view media files</div>';
                document.getElementById('pagination-top').style.display = 'none';
                document.getElementById('pagination-bottom').style.display = 'none';
                updatePaginationControls(0);
                populatePageSelect(0);
                populateStickerSetSelect();
                return;
            }

            if (allMediaFiles.length === 0) {
                container.innerHTML = '<div class="loading">No media files found</div>';
                document.getElementById('pagination-top').style.display = 'none';
                document.getElementById('pagination-bottom').style.display = 'none';
                updatePaginationControls(0);
                populatePageSelect(0);
                populateStickerSetSelect();
                return;
            }

            // Calculate pagination
            const totalItems = allMediaFiles.length;
            const totalPages = totalItems === 0 ? 0 : Math.ceil(totalItems / itemsPerPage);
            currentTotalPages = totalPages;
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, allMediaFiles.length);
            const pageItems = allMediaFiles.slice(startIndex, endIndex);

            // Build HTML for current page
            let html = '';

            let lastStickerSet = null;
            pageItems.forEach(media => {
                // Add sticker set header if it changed
                if (media.sticker_set_display !== lastStickerSet) {
                    if (lastStickerSet !== null) {
                        html += '</div>'; // Close previous grid
                    }
                    // Use prefix version for section headers to distinguish emoji from sticker sets
                    const headerText = media.sticker_set_display_with_prefix || media.sticker_set_display;
                    html += `<h2 style="margin: 16px 0 8px 0; color: #2c3e50; font-size: 18px; font-weight: 600;">${headerText}</h2>`;
                    html += '<div class="media-grid">';
                    lastStickerSet = media.sticker_set_display;
                }
                html += createMediaItemHTML(media);
            });

            // Close the last grid if we opened one
            if (lastStickerSet !== null) {
                html += '</div>';
            }
            container.innerHTML = html;

            // Update pagination controls
            updatePaginationControls(totalPages);
            populatePageSelect(totalPages);
            populateStickerSetSelect();

            // Populate move directory dropdowns
            populateMoveDirectoryDropdowns();

            // Load TGS animations (with a small delay to ensure DOM is updated)
            setTimeout(() => {
                loadTGSAnimations();
            }, 100);

            // Scroll to relevant media item or top
            if (pendingScrollToMediaId) {
                setTimeout(() => {
                    scrollToMediaItem(pendingScrollToMediaId);
                    pendingScrollToMediaId = null;
                }, 0);
            } else {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        function updatePaginationControls(totalPages) {
            const hasItems = allMediaFiles.length > 0 && currentDirectory;
            // Show/hide and enable/disable buttons
            const topContainer = document.getElementById('pagination-top');
            const bottomContainer = document.getElementById('pagination-bottom');
            if (topContainer) {
                topContainer.style.display = hasItems ? 'flex' : 'none';
            }
            if (bottomContainer) {
                bottomContainer.style.display = hasItems ? 'flex' : 'none';
            }

            // Disable previous button on first page
            const prevDisabled = currentPage === 1;
            document.getElementById('prev-btn').disabled = prevDisabled;
            document.getElementById('prev-btn-bottom').disabled = prevDisabled;
            document.getElementById('prev-btn').style.opacity = prevDisabled ? '0.5' : '1';
            document.getElementById('prev-btn-bottom').style.opacity = prevDisabled ? '0.5' : '1';
            document.getElementById('prev-btn').style.cursor = prevDisabled ? 'not-allowed' : 'pointer';
            document.getElementById('prev-btn-bottom').style.cursor = prevDisabled ? 'not-allowed' : 'pointer';

            // Disable next button on last page
            const nextDisabled = currentPage === totalPages || !hasItems || totalPages === 0;
            document.getElementById('next-btn').disabled = nextDisabled;
            document.getElementById('next-btn-bottom').disabled = nextDisabled;
            document.getElementById('next-btn').style.opacity = nextDisabled ? '0.5' : '1';
            document.getElementById('next-btn-bottom').style.opacity = nextDisabled ? '0.5' : '1';
            document.getElementById('next-btn').style.cursor = nextDisabled ? 'not-allowed' : 'pointer';
            document.getElementById('next-btn-bottom').style.cursor = nextDisabled ? 'not-allowed' : 'pointer';
        }

        function setupPaginationControls() {
            const pageSelects = [
                document.getElementById('page-select'),
                document.getElementById('page-select-bottom'),
            ];

            pageSelects.forEach((select) => {
                if (!select) {
                    return;
                }
                select.addEventListener('change', (event) => {
                    const value = parseInt(event.target.value, 10);
                    if (Number.isNaN(value)) {
                        return;
                    }
                    jumpToPage(value);
                });
            });

            const stickerSetSelect = document.getElementById('sticker-set-select');
            if (stickerSetSelect) {
                stickerSetSelect.addEventListener('change', (event) => {
                    const selectedSet = event.target.value;
                    if (!selectedSet) {
                        return;
                    }
                    jumpToStickerSet(selectedSet);
                    event.target.value = '';
                });
            }
        }

        function populatePageSelect(totalPages) {
            const hasItems = allMediaFiles.length > 0;
            const pageSelects = [
                document.getElementById('page-select'),
                document.getElementById('page-select-bottom'),
            ];

            pageSelects.forEach((select) => {
                if (!select) {
                    return;
                }

                select.innerHTML = '';

                const placeholderOption = document.createElement('option');
                placeholderOption.value = '';
                placeholderOption.textContent = 'Go to page…';
                placeholderOption.disabled = true;
                placeholderOption.hidden = hasItems;
                select.appendChild(placeholderOption);

                if (hasItems) {
                    for (let page = 1; page <= totalPages; page += 1) {
                        const option = document.createElement('option');
                        option.value = String(page);
                        option.textContent = `Page ${page}`;
                        select.appendChild(option);
                    }

                    select.value = String(currentPage);
                    select.disabled = totalPages <= 1;
                } else {
                    select.value = '';
                    select.disabled = true;
                }
            });
        }

        function populateStickerSetSelect() {
            const stickerSetSelect = document.getElementById('sticker-set-select');
            if (!stickerSetSelect) {
                return;
            }

            const previousValue = stickerSetSelect.value;
            stickerSetSelect.innerHTML = '';

            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = 'Jump to…';
            stickerSetSelect.appendChild(placeholder);

            if (!stickerSetOrder.length) {
                stickerSetSelect.value = '';
                stickerSetSelect.disabled = true;
                return;
            }

            // Group sets by type: stickers, custom emoji, and other media
            const stickerSets = [];
            const emojiSets = [];
            const otherMedia = [];
            
            stickerSetOrder.forEach((setName) => {
                const displayName = (window.stickerSetDisplayNames && window.stickerSetDisplayNames[setName]) 
                    ? window.stickerSetDisplayNames[setName] 
                    : setName;
                const isEmojiSet = window.stickerSetTypes && window.stickerSetTypes[setName];
                
                if (setName.startsWith("Other Media")) {
                    otherMedia.push({ value: setName, text: displayName });
                } else if (isEmojiSet) {
                    emojiSets.push({ value: setName, text: displayName });
                } else {
                    stickerSets.push({ value: setName, text: displayName });
                }
            });
            
            // Sort each group case-insensitively by display text
            const caseInsensitiveSort = (a, b) => a.text.localeCompare(b.text, undefined, { sensitivity: 'base' });
            stickerSets.sort(caseInsensitiveSort);
            emojiSets.sort(caseInsensitiveSort);
            otherMedia.sort(caseInsensitiveSort);
            
            // Add all sets in order: stickers, emoji, other
            [...stickerSets, ...emojiSets, ...otherMedia].forEach(({ value, text }) => {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = text;
                stickerSetSelect.appendChild(option);
            });

            if (previousValue && stickerSetStartIndexMap[previousValue] !== undefined) {
                stickerSetSelect.value = previousValue;
            } else {
                stickerSetSelect.value = '';
            }
            stickerSetSelect.disabled = false;
        }

        function jumpToPage(pageNumber) {
            if (!currentDirectory) return; // Don't paginate if no directory selected
            const page = Number(pageNumber);
            const totalPages = currentTotalPages || Math.ceil(allMediaFiles.length / itemsPerPage) || 1;

            if (Number.isNaN(page) || page < 1 || page > totalPages || page === currentPage) {
                return;
            }

            pendingScrollToMediaId = null;
            currentPage = page;
            displayCurrentPage();
        }

        function jumpToStickerSet(stickerSetName) {
            const startIndex = stickerSetStartIndexMap[stickerSetName];
            if (typeof startIndex !== 'number') {
                return;
            }

            const targetMediaId = stickerSetFirstMediaMap[stickerSetName];
            pendingScrollToMediaId = targetMediaId || null;

            const totalPages = currentTotalPages || Math.ceil(allMediaFiles.length / itemsPerPage) || 1;
            const desiredPage = Math.floor(startIndex / itemsPerPage) + 1;
            const targetPage = Math.min(Math.max(1, desiredPage), totalPages);

            if (targetPage !== currentPage) {
                currentPage = targetPage;
                displayCurrentPage();
            } else if (pendingScrollToMediaId) {
                setTimeout(() => {
                    scrollToMediaItem(pendingScrollToMediaId);
                    pendingScrollToMediaId = null;
                }, 0);
            }
        }

        function scrollToMediaItem(mediaId) {
            if (!mediaId) {
                return;
            }
            const target = document.getElementById(`media-item-${mediaId}`);
            if (target) {
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function previousPage() {
            if (!currentDirectory) return; // Don't paginate if no directory selected
            if (currentPage > 1) {
                currentPage--;
                pendingScrollToMediaId = null;
                displayCurrentPage();
            }
        }

        function nextPage() {
            if (!currentDirectory) return; // Don't paginate if no directory selected
            const totalPages = Math.ceil(allMediaFiles.length / itemsPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                pendingScrollToMediaId = null;
                displayCurrentPage();
            }
        }

        function createMediaItemHTML(media) {
            const encodedDir = encodeURIComponent(currentDirectory);
            const mediaUrl = `${API_BASE}/media/${media.unique_id}?directory=${encodedDir}`;
            const mimeType = (media.mime_type || '').toLowerCase();
            let mediaElement = '';
            const fallbackTypeFromFile = (fileName) => {
                if (!fileName) return '';
                const lower = fileName.toLowerCase();
                if (lower.endsWith('.tgs')) return 'application/x-tgsticker';
                if (lower.endsWith('.webm')) return 'video/webm';
                if (lower.endsWith('.mp4')) return 'video/mp4';
                if (lower.endsWith('.gif')) return 'image/gif';
                if (lower.endsWith('.ogg')) return 'audio/ogg';
                if (lower.endsWith('.mp3')) return 'audio/mpeg';
                if (lower.endsWith('.m4a')) return 'audio/mp4';
                if (lower.endsWith('.wav')) return 'audio/wav';
                if (lower.endsWith('.png')) return 'image/png';
                if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
                return '';
            };
            const lowerMediaFile = (media.media_file || '').toLowerCase();
            let effectiveMime = mimeType || fallbackTypeFromFile(media.media_file);
            if (!effectiveMime && lowerMediaFile.endsWith('.tgs')) {
                effectiveMime = 'application/x-tgsticker';
            }
            if (effectiveMime === 'application/gzip' && lowerMediaFile.endsWith('.tgs')) {
                effectiveMime = 'application/x-tgsticker';
            }
            effectiveMime = (effectiveMime || '').toLowerCase();

            // Check for audio files first (before other media types to ensure proper detection)
            const isAudioFile = (
                effectiveMime.startsWith('audio') ||
                media.kind === 'audio' ||
                (!effectiveMime.startsWith('video') && lowerMediaFile && (
                    lowerMediaFile.endsWith('.mp3') || 
                    lowerMediaFile.endsWith('.m4a') || 
                    lowerMediaFile.endsWith('.wav') || 
                    lowerMediaFile.endsWith('.ogg') ||
                    lowerMediaFile.endsWith('.opus') ||
                    lowerMediaFile.endsWith('.flac')
                ))
            );

            if (effectiveMime.includes('tgs') || media.kind === 'animated_sticker') {
                    // TGS files - Lottie animations, convert and display
                    mediaElement = `<div style="position: relative; width: 100%; height: 200px; display: flex; align-items: center; justify-content: center;">
                        <div id="tgs-player-${media.unique_id}" class="tgs-animation-container" style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">
                            <div style="text-align: center; color: #666;">
                                <div style="font-size: 24px; margin-bottom: 10px;">🎭</div>
                                <div style="font-size: 12px; margin-bottom: 10px;">Loading TGS animation...</div>
                                <a href="${mediaUrl}" download style="color: #007bff; text-decoration: none; font-size: 11px;">Download TGS</a>
                            </div>
                        </div>
                    </div>`;
            } else if (isAudioFile) {
                    // Audio files - Audio controls
                    // Determine audio MIME type for the source tag
                    let audioMimeType;
                    if (!effectiveMime || !effectiveMime.startsWith('audio/')) {
                        // Fallback: determine from file extension
                        if (lowerMediaFile.endsWith('.ogg') || lowerMediaFile.endsWith('.opus')) {
                            audioMimeType = 'audio/ogg';
                        } else if (lowerMediaFile.endsWith('.m4a')) {
                            audioMimeType = 'audio/mp4';
                        } else if (lowerMediaFile.endsWith('.wav')) {
                            audioMimeType = 'audio/wav';
                        } else if (lowerMediaFile.endsWith('.flac')) {
                            audioMimeType = 'audio/flac';
                        } else {
                            audioMimeType = 'audio/mpeg'; // Default to mp3 since effectiveMime is not a valid audio type
                        }
                    } else {
                        audioMimeType = effectiveMime;
                    }
                    mediaElement = `<audio controls preload="metadata" style="width: 100%; height: auto; min-height: 48px;">
                        <source src="${mediaUrl}" type="${audioMimeType}">
                        Your browser does not support the audio tag.
                    </audio>`;
            } else if (effectiveMime.startsWith('video') || effectiveMime === 'image/gif') {
                    // Video content (mp4/webm/gif)
                    const poster = media.thumbnail_url ? ` poster="${media.thumbnail_url}"` : '';
                    mediaElement = `<video controls preload="metadata" style="width: 100%; height: auto;"${poster}>
                        <source src="${mediaUrl}" type="${effectiveMime || 'video/mp4'}">
                        Your browser does not support the video tag.
                    </video>`;
            } else if (mediaUrl) {
                    mediaElement = `<img src="${mediaUrl}" alt="${media.sticker_name || media.unique_id}">`;
            } else {
                mediaElement = '<div style="color: #666;">No media file</div>';
            }

            // Format sticker name with emoji description
            const stickerName = media.sticker_name || media.unique_id;
            const displayName = (media.sticker_name && media.emoji_description)
                ? `${escapeHtml(media.sticker_name)} (${escapeHtml(media.emoji_description)})`
                : escapeHtml(stickerName);
            
            // Add document ID to title if it's not already shown
            const titleWithId = (displayName !== media.unique_id && media.unique_id)
                ? `${displayName} [${escapeHtml(media.unique_id)}]`
                : displayName;
            
            // Determine type display - show "custom emoji" for emoji sets
            let typeDisplay = escapeHtml(media.kind);
            if ((media.kind === 'sticker' || media.kind === 'animated_sticker') && media.is_emoji_set) {
                typeDisplay = media.kind === 'animated_sticker' ? 'custom emoji (animated)' : 'custom emoji';
            }

            return `
                <div class="media-item" id="media-item-${media.unique_id}" style="border: 1px solid #ddd; border-radius: 8px; margin-bottom: 20px; padding: 15px; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); width: 100%; max-width: 100%; box-sizing: border-box;">
                    <div class="media-preview">
                        ${mediaElement}
                    </div>
                    <div class="media-info">
                        <h3 style="margin-top: 10px; margin-bottom: 10px;">${titleWithId}</h3>
                        <p><strong>Type:</strong> ${typeDisplay}</p>
                        ${(media.kind === 'sticker' || media.kind === 'animated_sticker') ? `<p><strong>Set:</strong> ${escapeHtml(media.sticker_set_display || media.sticker_set_name)}</p>` : ''}
                        <p><strong>Status:</strong> ${escapeHtml(media.status)}</p>
                        ${media.failure_reason ? `<p class="error">${escapeHtml(media.failure_reason)}</p>` : ''}

                        <div class="description-edit">
                            <textarea id="desc-${media.unique_id}" placeholder="Enter description..." oninput="scheduleAutoSave('${escJsAttr(media.unique_id)}')" style="width: 100%; min-height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: inherit; resize: vertical; box-sizing: border-box;">${escapeHtml(media.description || '')}</textarea>
                            <div style="display: flex; align-items: center; margin-top: 8px; gap: 10px; flex-wrap: wrap;">
                                <span id="save-status-${media.unique_id}" style="font-size: 12px; color: #28a745;">Saved</span>
                                <button id="refresh-ai-btn-${media.unique_id}" onclick="refreshFromAI('${escJsAttr(media.unique_id)}')" style="padding: 4px 8px; font-size: 11px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer;">Refresh from AI</button>
                                <select id="move-dir-${media.unique_id}" onchange="moveMedia('${escJsAttr(media.unique_id)}')" style="padding: 4px 6px; font-size: 11px; border: 1px solid #ddd; border-radius: 3px; background: white;">
                                    <option value="">Move to...</option>
                                </select>
                                <button id="delete-btn-${media.unique_id}" onclick="deleteMedia('${escJsAttr(media.unique_id)}')" style="padding: 4px 8px; font-size: 11px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        async function loadTGSAnimations() {
            // Find all TGS player containers
            const tgsContainers = document.querySelectorAll('[id^="tgs-player-"]');
            console.log(`Found ${tgsContainers.length} TGS containers to load`);

            for (const container of tgsContainers) {
                const uniqueId = container.id.replace('tgs-player-', '');
                const encodedDir = encodeURIComponent(currentDirectory);
                const mediaUrl = `${API_BASE}/media/${uniqueId}?directory=${encodedDir}`;
                console.log(`Loading TGS for ${uniqueId} from ${mediaUrl}`);

                try {
                    // Fetch the TGS file
                    const response = await fetchWithAuth(mediaUrl);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch TGS file: ${response.status}`);
                    }

                    const tgsData = await response.arrayBuffer();
                    console.log(`Fetched TGS data: ${tgsData.byteLength} bytes`);

                    // Decompress the gzipped Lottie data
                    let lottieJson;

                    // Try pako first since DecompressionStream is unreliable
                    if (typeof pako !== 'undefined') {
                        try {
                            console.log('Attempting pako decompression...');
                            const decompressed = pako.inflate(new Uint8Array(tgsData), { to: 'string' });
                            lottieJson = JSON.parse(decompressed);
                            console.log('Pako decompression successful');
                        } catch (pakoError) {
                            console.error('Pako decompression failed:', pakoError);
                            throw new Error('Failed to decompress TGS file with pako');
                        }
                    } else {
                        // Fallback to DecompressionStream if pako not available
                        try {
                            console.log('Attempting DecompressionStream decompression...');
                            const decompressedData = await decompressGzip(tgsData);
                            const jsonText = new TextDecoder().decode(decompressedData);
                            lottieJson = JSON.parse(jsonText);
                            console.log('DecompressionStream decompression successful');
                        } catch (decompError) {
                            console.error('DecompressionStream failed:', decompError.message);
                            throw new Error('Failed to decompress TGS file - no suitable decompression method available');
                        }
                    }

                    // Clear the loading content and create a new container for Lottie
                    container.innerHTML = '';
                    const animationContainer = document.createElement('div');
                    animationContainer.style.width = '100%';
                    animationContainer.style.height = '100%';
                    animationContainer.style.display = 'flex';
                    animationContainer.style.alignItems = 'center';
                    animationContainer.style.justifyContent = 'center';
                    animationContainer.style.backgroundColor = '#ffffff';
                    container.appendChild(animationContainer);

                    // Initialize Lottie animation
                    console.log('Initializing Lottie animation...');
                    const animation = lottie.loadAnimation({
                        container: animationContainer,
                        renderer: 'svg',
                        loop: true,
                        autoplay: true,
                        animationData: lottieJson
                    });
                    console.log('Lottie animation initialized successfully');

                    // Handle animation errors
                            animation.addEventListener('error', (error) => {
                                console.error('Lottie animation error:', error);
                                container.innerHTML = `
                                    <div style="text-align: center; color: #dc3545;">
                                        <div style="font-size: 16px; margin-bottom: 5px;">⚠️</div>
                                        <div style="font-size: 11px;">Animation Error</div>
                                        <div style="font-size: 10px; margin-top: 5px;">${escapeHtml(error.message || 'Unknown error')}</div>
                                    </div>
                                `;
                            });

                    // Handle successful loading
                    animation.addEventListener('DOMLoaded', () => {
                        console.log('Lottie animation DOM loaded successfully');
                    });

                } catch (error) {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    console.error(`Failed to load TGS animation for ${uniqueId}:`, error);
                    container.innerHTML = `
                        <div style="text-align: center; color: #dc3545;">
                            <div style="font-size: 16px; margin-bottom: 5px;">⚠️</div>
                            <div style="font-size: 11px;">Load Failed</div>
                            <div style="font-size: 10px; margin-top: 5px;">${escapeHtml(error.message || 'Unknown error')}</div>
                            <a href="${mediaUrl}" download style="color: #007bff; text-decoration: none; font-size: 10px; margin-top: 5px; display: block;">Download TGS</a>
                        </div>
                    `;
                }
            }
        }

        // Simple gzip decompression using browser APIs
        async function decompressGzip(data) {
            // Check if DecompressionStream is supported
            if (!('DecompressionStream' in window)) {
                console.log('DecompressionStream not supported in this browser');
                throw new Error('DecompressionStream not supported in this browser');
            }

            try {
                console.log('Creating DecompressionStream...');
                const stream = new DecompressionStream('gzip');
                const writer = stream.writable.getWriter();
                const reader = stream.readable.getReader();

                console.log('Writing data to stream...');
                await writer.write(data);
                await writer.close();

                console.log('Reading decompressed data...');
                const chunks = [];
                let done = false;

                while (!done) {
                    const { value, done: readerDone } = await reader.read();
                    done = readerDone;
                    if (value) {
                        chunks.push(value);
                    }
                }

                console.log(`Decompressed into ${chunks.length} chunks`);
                const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const result = new Uint8Array(totalLength);
                let offset = 0;

                for (const chunk of chunks) {
                    result.set(chunk, offset);
                    offset += chunk.length;
                }

                console.log(`Total decompressed size: ${result.length} bytes`);
                return result;
            } catch (error) {
                console.error('DecompressionStream error:', error);
                throw new Error(`Failed to decompress gzip data: ${error.message}`);
            }
        }

        function scheduleAutoSave(uniqueId) {
            // Clear existing timer for this textarea
            if (autoSaveTimers[uniqueId]) {
                clearTimeout(autoSaveTimers[uniqueId]);
            }

            // Set new timer for 1 second delay
            autoSaveTimers[uniqueId] = setTimeout(() => {
                updateDescription(uniqueId);
            }, 1000);

            // Update status to show "typing..."
            updateSaveStatus(uniqueId, 'typing');
        }

        function updateSaveStatus(uniqueId, status) {
            const statusElement = document.getElementById(`save-status-${uniqueId}`);
            if (!statusElement) return;

            switch (status) {
                case 'typing':
                    statusElement.textContent = 'Saving...';
                    statusElement.style.color = '#007bff';
                    break;
                case 'saving':
                    statusElement.textContent = 'Saving...';
                    statusElement.style.color = '#007bff';
                    break;
                case 'saved':
                    statusElement.textContent = 'Saved';
                    statusElement.style.color = '#28a745';
                    break;
                case 'error':
                    statusElement.textContent = 'Error';
                    statusElement.style.color = '#dc3545';
                    break;
                default:
                    statusElement.textContent = 'Saved';
                    statusElement.style.color = '#28a745';
            }
        }

        function updateDescription(uniqueId) {
            // Don't save if already saving
            if (savingStates[uniqueId]) {
                return;
            }

            const textarea = document.getElementById(`desc-${uniqueId}`);
            const description = textarea.value.trim();
            const encodedDir = encodeURIComponent(currentDirectory);

            // Mark as saving
            savingStates[uniqueId] = true;
            updateSaveStatus(uniqueId, 'saving');

            fetchWithAuth(`${API_BASE}/media/${uniqueId}/description?directory=${encodedDir}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ description: description })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    updateSaveStatus(uniqueId, 'error');
                } else {
                    // Re-get textarea element for DOM traversal (use outer 'description' variable that was saved)
                    const textareaEl = document.getElementById(`desc-${uniqueId}`);
                    
                    updateSaveStatus(uniqueId, 'saved');

                    // Only show "curated" status if description was actually provided
                    // (backend only sets curated status when description is non-empty)
                    // Use the textarea to find the parent media item
                    let mediaItem = null;
                    if (textareaEl) {
                        mediaItem = textareaEl.closest('.media-item');
                    }
                    
                    // Fallback: try to find by ID
                    if (!mediaItem) {
                        mediaItem = document.getElementById(`media-item-${uniqueId}`);
                    }

                    if (mediaItem) {
                        const statusElements = mediaItem.querySelectorAll('p');
                        for (const p of statusElements) {
                            if (p.textContent.includes('Status:')) {
                                if (description) {
                                    p.innerHTML = '<strong>Status:</strong> curated';
                                }
                                // If description is empty, don't change status - keep existing status from backend
                            } else if (p.classList.contains('error')) {
                                // Clear the error message (failure_reason) only if description was provided
                                if (description) {
                                    p.remove();
                                }
                            }
                        }
                    }
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                updateSaveStatus(uniqueId, 'error');
            })
            .finally(() => {
                // Mark as no longer saving
                savingStates[uniqueId] = false;
            });
        }

        function refreshFromAI(uniqueId) {
            const button = document.getElementById(`refresh-ai-btn-${uniqueId}`);
            const textarea = document.getElementById(`desc-${uniqueId}`);
            const encodedDir = encodeURIComponent(currentDirectory);

            // Disable button and show loading state
            button.disabled = true;
            button.textContent = 'Generating...';
            button.style.background = '#007bff';

            fetchWithAuth(`${API_BASE}/media/${uniqueId}/refresh-ai?directory=${encodedDir}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error refreshing from AI: ' + data.error);
                } else {
                    // Update the cached data in allMediaFiles array so pagination shows updated data
                    const mediaIndex = allMediaFiles.findIndex(m => m.unique_id === uniqueId);
                    if (mediaIndex !== -1) {
                        allMediaFiles[mediaIndex].description = data.description || null;
                        allMediaFiles[mediaIndex].status = data.status || 'ok';
                        // Clear failure_reason if status is successful
                        if (data.status && (
                            data.status === 'generated' || 
                            data.status === 'curated' ||
                            (data.status === 'budget_exhausted' && data.description)
                        )) {
                            allMediaFiles[mediaIndex].failure_reason = null;
                        }
                    }

                    // Update the textarea with the new AI-generated description
                    if (textarea) {
                        textarea.value = data.description || '';
                    }

                    // Update all UI elements that might have changed
                    // Use the textarea to find the parent media item
                    let mediaItem = null;
                    if (textarea) {
                        mediaItem = textarea.closest('.media-item');
                    }
                    
                    // Fallback: try to find by ID
                    if (!mediaItem) {
                        mediaItem = document.getElementById(`media-item-${uniqueId}`);
                    }

                    if (mediaItem) {
                        // Update status display
                        const statusElements = mediaItem.querySelectorAll('p');
                        for (const p of statusElements) {
                            if (p.textContent.includes('Status:')) {
                                p.innerHTML = `<strong>Status:</strong> ${escapeHtml(data.status || 'ok')}`;
                            } else if (p.classList.contains('error')) {
                                // Remove failure_reason display if status is successful
                                // Successful statuses: generated, curated, budget_exhausted (for stickers with fallback)
                                const isSuccess = data.status && (
                                    data.status === 'generated' || 
                                    data.status === 'curated' ||
                                    (data.status === 'budget_exhausted' && data.description)
                                );
                                if (isSuccess) {
                                    p.remove();
                                }
                            }
                        }

                        // Update save status to show "Saved" since refresh endpoint saved the record
                        const saveStatusEl = document.getElementById(`save-status-${uniqueId}`);
                        if (saveStatusEl) {
                            saveStatusEl.textContent = 'Saved';
                            saveStatusEl.style.color = '#28a745';
                        }
                    } else {
                        // If media item not found, reload the media list to get updated data
                        console.warn(`Media item not found for ${uniqueId}, reloading media list`);
                        loadMediaFiles(currentDirectory, true);
                    }

                    // Don't trigger auto-save - the refresh endpoint already saves the record
                    // If description is empty, the status will remain as returned by the refresh (e.g., permanent_failure)
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error refreshing from AI: ' + error);
            })
            .finally(() => {
                // Re-enable button
                button.disabled = false;
                button.textContent = 'Refresh from AI';
                button.style.background = '#6c757d';
            });
        }

        function populateMoveDirectoryDropdowns() {
            // Get all move directory dropdowns
            const moveDropdowns = document.querySelectorAll('[id^="move-dir-"]');

            // Fetch available directories
            fetchWithAuth(`${API_BASE}/directories`)
                .then(response => response.json())
                .then(directories => {
                    moveDropdowns.forEach(dropdown => {
                        // Clear existing options except the first one
                        while (dropdown.children.length > 1) {
                            dropdown.removeChild(dropdown.lastChild);
                        }

                        // Add directory options
                        directories.forEach(dir => {
                            if (dir.path !== currentDirectory) { // Don't show current directory
                                const option = document.createElement('option');
                                option.value = dir.path;
                                option.textContent = dir.name;
                                dropdown.appendChild(option);
                            }
                        });
                    });
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    console.error('Error loading directories for move dropdowns:', error);
                });
        }

        function moveMedia(uniqueId) {
            const select = document.getElementById(`move-dir-${uniqueId}`);
            const targetDirectory = select.value;

            if (!targetDirectory) {
                return; // No selection made
            }

            const encodedCurrentDir = encodeURIComponent(currentDirectory);
            const encodedTargetDir = encodeURIComponent(targetDirectory);

            // Show loading state
            select.disabled = true;
            select.style.background = '#f8f9fa';

            fetchWithAuth(`${API_BASE}/media/${uniqueId}/move?from_directory=${encodedCurrentDir}&to_directory=${encodedTargetDir}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error moving media: ' + data.error);
                    select.disabled = false;
                    select.style.background = 'white';
                    select.value = '';
                } else {
                    // Reload the current directory to refresh the list, preserving current page
                    loadMediaFiles(currentDirectory, true);
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error moving media: ' + error);
                select.disabled = false;
                select.style.background = 'white';
                select.value = '';
            });
        }

        function deleteMedia(uniqueId) {
            const mediaName = document.querySelector(`#desc-${uniqueId}`).placeholder || 'this media item';

            if (confirm(`Are you sure you want to delete ${mediaName}? This will permanently remove both the media file and description.`)) {
                const button = document.getElementById(`delete-btn-${uniqueId}`);
                const encodedDir = encodeURIComponent(currentDirectory);

                // Show loading state
                button.disabled = true;
                button.textContent = 'Deleting...';
                button.style.background = '#6c757d';

                fetchWithAuth(`${API_BASE}/media/${uniqueId}/delete?directory=${encodedDir}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert('Error deleting media: ' + data.error);
                        button.disabled = false;
                        button.textContent = 'Delete';
                        button.style.background = '#dc3545';
                    } else {
                        // Reload the current directory to refresh the list, preserving current page
                        loadMediaFiles(currentDirectory, true);
                    }
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    alert('Error deleting media: ' + error);
                    button.disabled = false;
                    button.textContent = 'Delete';
                    button.style.background = '#dc3545';
                });
            }
        }

        function importStickerSet() {
            const stickerSetName = document.getElementById('sticker-set-name').value.trim();
            const statusDiv = document.getElementById('import-status');

            if (!stickerSetName) {
                statusDiv.innerHTML = '<div class="error">Please enter a sticker set name</div>';
                return;
            }

            if (!currentDirectory) {
                statusDiv.innerHTML = '<div class="error">Please select a directory first</div>';
                return;
            }

            statusDiv.innerHTML = '<div>Importing sticker set...</div>';

            fetchWithAuth(`${API_BASE}/import-sticker-set`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    sticker_set_name: stickerSetName,
                    target_directory: currentDirectory
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    statusDiv.innerHTML = `<div class="error">Error: ${escapeHtml(data.error)}</div>`;
                } else {
                    statusDiv.innerHTML = '<div style="color: #28a745;">Import completed!</div>';
                    // Reload media files
                    loadMediaFiles(currentDirectory);
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    statusDiv.innerHTML = '<div class="error">Session expired. Please verify again.</div>';
                    return;
                }
                statusDiv.innerHTML = `<div class="error">Error: ${escapeHtml(error)}</div>`;
            });
        }

        // Main tab switching logic - use event delegation
        // The main tab bar is directly after the header, subtab bars are inside tab panels
        function handleMainTabClick(e) {
            const button = e.target.closest('button.tab-button[data-tab]');
            if (!button) return;
            
            // Make sure it's in the main tab bar (not a subtab)
            const mainTabBar = document.querySelector('.header').nextElementSibling;
            if (!mainTabBar || !mainTabBar.classList.contains('tab-bar')) return;
            if (!mainTabBar.contains(button)) return;
            
            // Make sure it's not a subtab button
            if (button.hasAttribute('data-subtab') && !button.hasAttribute('data-tab')) return;
            
            e.preventDefault();
            e.stopPropagation();
            const tabName = button.getAttribute('data-tab');
            if (!tabName) return;
            
            // Update main tab buttons (only top-level ones)
            mainTabBar.querySelectorAll('.tab-button[data-tab]').forEach(btn => {
                btn.classList.remove('active');
            });
            button.classList.add('active');
            
            // Update main tab panels - clear all first
            document.querySelectorAll('.tab-panel[data-tab-panel]').forEach(panel => {
                panel.classList.remove('active');
                panel.style.display = ''; // Clear inline display style to let CSS handle it
            });
            
            // Activate the selected panel
            const panel = document.querySelector(`.tab-panel[data-tab-panel="${tabName}"]`);
            if (panel) {
                panel.classList.add('active');
                panel.style.display = 'block'; // Explicitly set to ensure visibility
                
                // Ensure subtab bar is visible
                const subtabBar = panel.querySelector('.tab-bar');
                if (subtabBar) {
                    subtabBar.style.display = 'flex';
                    subtabBar.style.visibility = 'visible';
                    subtabBar.style.opacity = '1';
                    subtabBar.style.height = 'auto';
                    subtabBar.style.minHeight = '40px';
                    
                    // Force show each button
                    const subtabButtons = subtabBar.querySelectorAll('.tab-button[data-subtab]');
                    subtabButtons.forEach(btn => {
                        btn.style.display = 'inline-block';
                        btn.style.visibility = 'visible';
                        btn.style.opacity = '1';
                    });
                }
            }
            
            // Load data when switching to main tabs
            // Always reload agents dropdown when switching to Agents or Conversations tabs
            if (tabName === 'agents' || tabName === 'conversations') {
                loadAgents();
            }
            
            if (tabName === 'agents') {
                // Show first subtab (which will also call loadAgents)
                switchSubtab('profile');
            } else if (tabName === 'conversations') {
                // Show first subtab (which will also call loadAgents)
                switchSubtab('notes-conv');
                // Load recent conversations
                loadRecentConversations();
                // If an agent is already selected, load conversation partners
                const conversationsAgentSelect = document.getElementById('conversations-agent-select');
                const agentName = conversationsAgentSelect?.value;
                if (agentName) {
                    loadConversationPartners(agentName, 'conversations');
                }
            } else if (tabName === 'global') {
                // Global tab - show first subtab
                switchSubtab('media');
            }
        }
        
        // Attach event delegation to the main tab bar
        const mainTabBar = document.querySelector('.header').nextElementSibling;
        if (mainTabBar && mainTabBar.classList.contains('tab-bar')) {
            mainTabBar.addEventListener('click', handleMainTabClick);
        }

        // Subtab switching logic (for Global, Agents and Conversations tabs)
        function switchSubtab(subtabName) {
            // Get the active main tab - check global, agents and conversations tabs
            // First try to find an active tab panel
            let activeMainTab = document.querySelector('.tab-panel.active[data-tab-panel="global"]');
            if (!activeMainTab) {
                activeMainTab = document.querySelector('.tab-panel.active[data-tab-panel="agents"]');
            }
            if (!activeMainTab) {
                activeMainTab = document.querySelector('.tab-panel.active[data-tab-panel="conversations"]');
            }
            
            // If no active tab found, try to find by checking which main tab button is active
            if (!activeMainTab) {
                const activeMainTabButton = document.querySelector('nav.tab-bar:first-of-type .tab-button.active[data-tab]');
                if (activeMainTabButton) {
                    const tabName = activeMainTabButton.getAttribute('data-tab');
                    activeMainTab = document.querySelector(`.tab-panel[data-tab-panel="${tabName}"]`);
                }
            }
            
            // If still not found, this shouldn't happen, but return early
            if (!activeMainTab) {
                return;
            }
            
            // Ensure the main tab panel stays active and visible
            activeMainTab.classList.add('active');
            activeMainTab.style.display = 'block'; // Explicitly set to block to ensure visibility
            
            // Ensure the subtab bar is visible
            const subtabBar = activeMainTab.querySelector('.tab-bar');
            if (subtabBar) {
                subtabBar.style.display = 'flex';
                subtabBar.style.visibility = 'visible';
                subtabBar.style.opacity = '1';
                subtabBar.style.height = 'auto';
                subtabBar.style.minHeight = '40px';
            }
            
            const mainTabName = activeMainTab.getAttribute('data-tab-panel');
            
            // Check if the subtab is already active - if so, we still want to reload data
            const wasAlreadyActive = activeMainTab.querySelector(`.tab-button[data-subtab="${subtabName}"]`)?.classList.contains('active');
            
            // Update subtab buttons within the active main tab
            const subtabButtons = activeMainTab.querySelectorAll('.tab-button[data-subtab]');
            subtabButtons.forEach(btn => {
                btn.classList.remove('active');
                btn.style.display = 'inline-block';
                btn.style.visibility = 'visible';
                btn.style.opacity = '1';
                if (btn.getAttribute('data-subtab') === subtabName) {
                    btn.classList.add('active');
                }
            });
            
            // Update subtab panels within the active main tab
            const subtabPanels = activeMainTab.querySelectorAll('.subtab-panel');
            subtabPanels.forEach(panel => {
                panel.classList.remove('active');
                if (panel.getAttribute('data-subtab-panel') === subtabName) {
                    panel.classList.add('active');
                }
            });
            
            // Load data for the subtab
            // Always reload agents dropdown when switching subtabs in Agents or Conversations tabs
            // This ensures asterisks are updated for the current subtab
            if (mainTabName === 'agents' || mainTabName === 'conversations') {
                loadAgents();
            }
            
            if (mainTabName === 'agents') {
                const agentSelect = document.getElementById('agents-agent-select');
                // Capture agentName right before use to ensure it's current
                // This prevents using stale values if loadAgents() is still updating the select
                const agentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
                if (agentName) {
                    // Always reload data, even if the subtab was already active
                    // This ensures fresh data when clicking the same tab again
                    if (subtabName === 'profile') {
                        loadAgentProfile(agentName);
                    } else if (subtabName === 'parameters') {
                        loadAgentConfiguration(agentName);
                    } else if (subtabName === 'memories') {
                        // loadMemories will validate agentName matches current selection
                        loadMemories(agentName);
                    } else if (subtabName === 'intentions') {
                        loadIntentions(agentName);
                    } else if (subtabName === 'documents-agent') {
                        loadAgentDocs(agentName);
                    } else if (subtabName === 'memberships') {
                        loadMemberships(agentName);
                    }
                } else {
                    // No agent selected - clear profile if switching to profile subtab
                    if (subtabName === 'profile') {
                        loadAgentProfile('');
                    }
                }
            } else if (mainTabName === 'global') {
                if (subtabName === 'documents-global') {
                    loadGlobalDocsConfigDirectories();
                } else if (subtabName === 'role-prompts') {
                    loadGlobalPromptsConfigDirectories();
                } else if (subtabName === 'parameters-global') {
                    loadGlobalParameters();
                }
            } else if (mainTabName === 'conversations') {
                // Reload conversation partners dropdown to update asterisks for new subtab
                const agentSelect = document.getElementById('conversations-agent-select');
                const agentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
                if (agentName) {
                    loadConversationPartners(agentName, 'conversations');
                }
                
                const partnerSelect = document.getElementById('conversations-partner-select');
                const userIdInput = document.getElementById('conversations-user-id');
                const userId = userIdInput?.value.trim() || (partnerSelect ? stripAsterisk(partnerSelect.value) : '');
                
                if (agentName && userId) {
                    if (subtabName === 'notes-conv') {
                        loadNotesForPartner();
                    } else if (subtabName === 'conversation-llm') {
                        loadConversationLLM();
                    } else if (subtabName === 'plans') {
                        loadPlans();
                    } else if (subtabName === 'conversation') {
                        loadConversation();
                    } else if (subtabName === 'xsend') {
                        // Show XSend content
                        const xsendContainer = document.getElementById('xsend-container');
                        const xsendContent = document.getElementById('xsend-content');
                        if (xsendContainer && xsendContent) {
                            xsendContainer.querySelector('.loading').style.display = 'none';
                            xsendContent.style.display = 'block';
                        }
                    }
                }
            }
        }

        // Subtab button click handlers - simple event delegation
        document.addEventListener('click', function(e) {
            const button = e.target.closest('button.tab-button[data-subtab]');
            if (!button) return;
            
            // Skip if it's a main tab button
            if (button.hasAttribute('data-tab')) return;
            
            // Must be inside a tab panel
            if (!button.closest('.tab-panel[data-tab-panel]')) return;
            
            const subtabName = button.getAttribute('data-subtab');
            if (subtabName) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                // Always call switchSubtab, even if the button is already active
                // This ensures data is reloaded when clicking an already-active tab
                switchSubtab(subtabName);
            }
        }, true);


        // Helper function to strip asterisks from agent/partner names for value comparison
        function stripAsterisk(text) {
            return text.replace(/\s*\*$/, '');
        }

        // Helper function to get current subtab name for agents tab
        function getCurrentAgentsSubtab() {
            const activeSubtab = document.querySelector('.tab-panel[data-tab-panel="agents"] .tab-button.active');
            return activeSubtab ? activeSubtab.getAttribute('data-subtab') : 'profile';
        }

        // Helper function to get current subtab name for conversations tab
        function getCurrentConversationsSubtab() {
            const activeSubtab = document.querySelector('.tab-panel[data-tab-panel="conversations"] .tab-button.active');
            return activeSubtab ? activeSubtab.getAttribute('data-subtab') : 'notes-conv';
        }

        // Helper function to check if agent has nontrivial content for a subtab
        async function agentHasContent(agentName, subtabName) {
            try {
                if (subtabName === 'parameters') {
                    // Check if agent has custom LLM or non-empty prompt
                    const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration`);
                    const data = await response.json();
                    if (data.error) return false;
                    const defaultLLM = data.available_llms?.find(llm => llm.is_default)?.value;
                    const hasCustomLLM = data.llm && data.llm !== defaultLLM;
                    const hasPrompt = data.prompt && data.prompt.trim().length > 0;
                    return hasCustomLLM || hasPrompt;
                } else if (subtabName === 'memories') {
                    const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/memories`);
                    const data = await response.json();
                    if (data.error) return false;
                    return data.memories && data.memories.length > 0;
                } else if (subtabName === 'intentions') {
                    const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/intentions`);
                    const data = await response.json();
                    if (data.error) return false;
                    return data.intentions && data.intentions.length > 0;
                } else if (subtabName === 'documents-agent') {
                    // Check if agent has documents using the has_documents field from agents list
                    // This is more efficient than making a separate API call
                    const response = await fetchWithAuth(`${API_BASE}/agents`);
                    const data = await response.json();
                    if (data.error) return false;
                    const agent = data.agents?.find(a => a.config_name === agentName);
                    return agent?.has_documents || false;
                } else if (subtabName === 'plans') {
                    // Check if agent has plans using the has_plans field from agents list
                    // This is more efficient than checking all conversations
                    const response = await fetchWithAuth(`${API_BASE}/agents`);
                    const data = await response.json();
                    if (data.error) return false;
                    const agent = data.agents?.find(a => a.config_name === agentName);
                    return agent?.has_plans || false;
                } else if (subtabName === 'profile') {
                    // Check if agent has profile content (non-empty profile fields)
                    const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/profile`);
                    const data = await response.json();
                    if (data.error) return false;
                    // Check if any profile fields are set (excluding telegram_id which is always present)
                    const hasFirstName = data.first_name && data.first_name.trim().length > 0;
                    const hasLastName = data.last_name && data.last_name.trim().length > 0;
                    const hasUsername = data.username && data.username.trim().length > 0;
                    const hasBio = data.bio && data.bio.trim().length > 0;
                    const hasBirthday = data.birthday && (data.birthday.day || data.birthday.month);
                    const hasProfilePhoto = data.profile_photo && data.profile_photo.length > 0;
                    return hasFirstName || hasLastName || hasUsername || hasBio || hasBirthday || hasProfilePhoto;
                }
            } catch (error) {
                if (error && error.message === 'unauthorized') {
                    return false;
                }
                console.error(`Error checking content for agent ${agentName}, subtab ${subtabName}:`, error);
            }
            return false;
        }

        // Helper function to check if conversation partner has nontrivial content for a subtab
        async function partnerHasContent(agentName, userId, subtabName) {
            try {
                if (subtabName === 'notes-conv') {
                    const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/notes/${userId}`);
                    const data = await response.json();
                    if (data.error) return false;
                    return data.notes && data.notes.length > 0;
                } else if (subtabName === 'conversation-llm') {
                    const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation-llm/${userId}`);
                    const data = await response.json();
                    if (data.error) return false;
                    const agentDefaultLLM = data.agent_default_llm;
                    return data.conversation_llm && data.conversation_llm !== agentDefaultLLM;
                } else if (subtabName === 'plans') {
                    const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/plans/${userId}`);
                    const data = await response.json();
                    if (data.error) return false;
                    return data.plans && data.plans.length > 0;
                } else if (subtabName === 'conversation') {
                    // For conversation subtab, check summaries locally (no Telegram API call)
                    // This is handled by the batch endpoint in loadConversationPartners
                    // Fallback: check summaries endpoint (still no Telegram API call)
                    const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/summaries/${userId}`);
                    const data = await response.json();
                    if (data.error) return false;
                    return data.summaries && data.summaries.length > 0;
                }
                // XSend subtab doesn't need asterisk
            } catch (error) {
                if (error && error.message === 'unauthorized') {
                    return false;
                }
                console.error(`Error checking content for partner ${userId}, subtab ${subtabName}:`, error);
            }
            return false;
        }

        // Load agents list
        async function createNewAgent(configDir) {
            try {
                const response = await fetchWithAuth(`${API_BASE}/agents/new`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ config_directory: configDir })
                });
                const data = await response.json();
                if (data.success) {
                    await loadAgents();
                    document.getElementById('agents-agent-select').value = data.config_name;
                    // Trigger change to load the new agent's config
                    document.getElementById('agents-agent-select').dispatchEvent(new Event('change'));
                } else {
                    alert('Error creating agent: ' + data.error);
                }
            } catch (error) {
                console.error('Error creating agent:', error);
                alert('Error creating agent');
            }
        }

        async function toggleAgentDisabled(agentName, isDisabled) {
            // Get button reference and store original state
            const button = document.getElementById('toggle-agent-button');
            if (!button) {
                console.error('Toggle agent button not found');
                return;
            }
            
            const originalText = button.textContent;
            const originalBackground = button.style.background;
            const originalCursor = button.style.cursor;
            const originalOpacity = button.style.opacity;
            
            // Immediately disable button and show loading state
            button.disabled = true;
            button.style.cursor = 'not-allowed';
            button.style.opacity = '0.6';
            button.textContent = isDisabled ? 'Disabling...' : 'Enabling...';
            
            // Helper function to restore button state
            const restoreButton = () => {
                button.disabled = false;
                button.style.cursor = originalCursor || 'pointer';
                button.style.opacity = originalOpacity || '1';
                button.textContent = originalText;
            };
            
            try {
                const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/disabled`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ is_disabled: isDisabled })
                });
                const data = await response.json();
                if (data.success) {
                    if (!isDisabled) {
                        // If enabling, trigger login check
                        await handleAgentLogin(agentName);
                        // loadAgentConfiguration will be called by handleAgentLogin to update the button
                    } else {
                        // Refresh configuration to update UI
                        loadAgentConfiguration(agentName);
                        // Also refresh agent list to show/hide (disabled)
                        loadAgents().then(() => {
                            document.getElementById('agents-agent-select').value = agentName;
                        });
                        // loadAgentConfiguration will update the button with correct state
                    }
                } else {
                    restoreButton();
                    alert('Error updating agent status: ' + data.error);
                }
            } catch (error) {
                console.error('Error toggling agent status:', error);
                restoreButton();
                alert('Error toggling agent status');
            }
        }

        async function handleAgentLogin(agentName) {
            try {
                const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/login`, {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.status === 'authenticated') {
                    alert('Agent is authenticated and enabled.');
                    loadAgentConfiguration(agentName);
                    loadAgents().then(() => {
                        document.getElementById('agents-agent-select').value = agentName;
                    });
                } else if (data.status === 'needs_code') {
                    const code = prompt('Enter the Telegram verification code for this agent:');
                    if (code) {
                        await submitAgentLoginCode(agentName, code);
                    } else {
                        await cancelAgentLogin(agentName);
                    }
                } else if (data.status === 'needs_password') {
                    const password = prompt('Enter the 2FA password for this agent:');
                    if (password) {
                        await submitAgentLoginPassword(agentName, password);
                    } else {
                        await cancelAgentLogin(agentName);
                    }
                } else if (data.error) {
                    alert('Login error: ' + data.error);
                    loadAgentConfiguration(agentName);
                    loadAgents().then(() => {
                        document.getElementById('agents-agent-select').value = agentName;
                    });
                } else {
                    // Handle unexpected status values
                    console.error('Unexpected login status:', data.status, data);
                    alert('Unexpected response from login API. Status: ' + (data.status || 'unknown'));
                    loadAgentConfiguration(agentName);
                    loadAgents().then(() => {
                        document.getElementById('agents-agent-select').value = agentName;
                    });
                }
            } catch (error) {
                console.error('Error during agent login:', error);
                alert('Error during agent login');
                loadAgentConfiguration(agentName);
                loadAgents().then(() => {
                    document.getElementById('agents-agent-select').value = agentName;
                });
            }
        }

        async function submitAgentLoginCode(agentName, code) {
            try {
                const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/login/code`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: code })
                });
                const data = await response.json();
                
                if (data.status === 'authenticated') {
                    alert('Agent successfully authenticated!');
                    loadAgentConfiguration(agentName);
                    loadAgents().then(() => {
                        document.getElementById('agents-agent-select').value = agentName;
                    });
                } else if (data.status === 'needs_password') {
                    const password = prompt('Enter the 2FA password for this agent:');
                    if (password) {
                        await submitAgentLoginPassword(agentName, password);
                    } else {
                        await cancelAgentLogin(agentName);
                    }
                } else if (data.error) {
                    alert('Error: ' + data.error);
                    await handleAgentLogin(agentName); // Let them try again
                } else {
                    // Handle unexpected status values
                    console.error('Unexpected login code status:', data.status, data);
                    alert('Unexpected response from login code API. Status: ' + (data.status || 'unknown'));
                    loadAgentConfiguration(agentName);
                    loadAgents().then(() => {
                        document.getElementById('agents-agent-select').value = agentName;
                    });
                }
            } catch (error) {
                console.error('Error submitting code:', error);
                alert('Error submitting code');
                loadAgentConfiguration(agentName);
                loadAgents().then(() => {
                    document.getElementById('agents-agent-select').value = agentName;
                });
            }
        }

        async function submitAgentLoginPassword(agentName, password) {
            try {
                const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/login/password`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password: password })
                });
                const data = await response.json();
                
                if (data.status === 'authenticated') {
                    alert('Agent successfully authenticated!');
                    loadAgentConfiguration(agentName);
                    loadAgents().then(() => {
                        document.getElementById('agents-agent-select').value = agentName;
                    });
                } else if (data.error) {
                    alert('Error: ' + data.error);
                    await handleAgentLogin(agentName); // Let them try again
                } else {
                    // Handle unexpected status values
                    console.error('Unexpected login password status:', data.status, data);
                    alert('Unexpected response from login password API. Status: ' + (data.status || 'unknown'));
                    loadAgentConfiguration(agentName);
                    loadAgents().then(() => {
                        document.getElementById('agents-agent-select').value = agentName;
                    });
                }
            } catch (error) {
                console.error('Error submitting password:', error);
                alert('Error submitting password');
                loadAgentConfiguration(agentName);
                loadAgents().then(() => {
                    document.getElementById('agents-agent-select').value = agentName;
                });
            }
        }

        async function cancelAgentLogin(agentName) {
            await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/login/cancel`, {
                method: 'POST'
            });
            loadAgentConfiguration(agentName);
            loadAgents().then(() => {
                document.getElementById('agents-agent-select').value = agentName;
            });
        }

        async function renameAgentConfig(agentName, newName) {
            if (!newName) {
                newName = prompt('Enter new config name (without .md):', agentName);
            }
            if (!newName || newName === agentName) {
                loadAgentConfiguration(agentName); // Refresh to revert input
                return;
            }

            try {
                const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/rename`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ new_config_name: newName })
                });
                const data = await response.json();
                if (data.success) {
                    const newConfigName = data.new_config_name;
                    await loadAgents();
                    document.getElementById('agents-agent-select').value = newConfigName;
                    loadAgentConfiguration(newConfigName);
                } else {
                    alert('Error renaming agent: ' + data.error);
                    loadAgentConfiguration(agentName);
                }
            } catch (error) {
                console.error('Error renaming agent:', error);
                alert('Error renaming agent');
                loadAgentConfiguration(agentName);
            }
        }

        async function moveAgentConfigDirectory(agentName, newConfigDirectory, currentConfigDirectory) {
            // Reset dropdown to current value first (will be updated on success)
            const select = document.getElementById('agent-config-directory-select');
            if (select) {
                select.value = currentConfigDirectory;
            }

            if (!newConfigDirectory || newConfigDirectory === currentConfigDirectory) {
                return;
            }

            // Show confirmation dialog
            const confirmed = confirm(
                `Are you sure you want to move agent "${agentName}" from config directory "${currentConfigDirectory}" to "${newConfigDirectory}"?\n\n` +
                `This will move:\n` +
                `- ${currentConfigDirectory}/agents/${agentName}.md\n` +
                `- ${currentConfigDirectory}/agents/${agentName}/\n\n` +
                `to the new config directory.`
            );

            if (!confirmed) {
                // Reset dropdown to current value
                if (select) {
                    select.value = currentConfigDirectory;
                }
                return;
            }

            try {
                const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/move-directory`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ config_directory: newConfigDirectory })
                });
                const data = await response.json();
                if (data.success) {
                    alert('Agent config directory moved successfully.');
                    // Reload agents list and configuration
                    await loadAgents();
                    loadAgentConfiguration(agentName);
                } else {
                    alert('Error moving config directory: ' + data.error);
                    // Reset dropdown to current value
                    if (select) {
                        select.value = currentConfigDirectory;
                    }
                    loadAgentConfiguration(agentName);
                }
            } catch (error) {
                console.error('Error moving config directory:', error);
                alert('Error moving config directory: ' + error);
                // Reset dropdown to current value
                if (select) {
                    select.value = currentConfigDirectory;
                }
                loadAgentConfiguration(agentName);
            }
        }

        async function deleteAgent(agentName, displayName) {
            const confirmation = prompt(`To delete agent "${displayName}", type DELETE ${displayName}:`);
            if (confirmation !== `DELETE ${displayName}`) {
                if (confirmation !== null) alert('Incorrect confirmation string.');
                return;
            }

            try {
                const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ confirmation: confirmation })
                });
                const data = await response.json();
                if (data.success) {
                    alert('Agent deleted successfully.');
                    await loadAgents();
                    document.getElementById('agents-agent-select').value = '';
                    document.getElementById('parameters-container').innerHTML = '<div class="loading">Select an agent to configure</div>';
                } else {
                    alert('Error deleting agent: ' + data.error);
                }
            } catch (error) {
                console.error('Error deleting agent:', error);
                alert('Error deleting agent');
            }
        }
        async function loadAgents() {
            try {
                const response = await fetchWithAuth(`${API_BASE}/agents`);
                const data = await response.json();
                if (data.error) {
                    console.error('Error loading agents:', data.error);
                    return;
                }
                
                const agents = data.agents || [];
                
                // Determine which subtab to check content for
                const agentsTabActive = document.querySelector('.tab-panel[data-tab-panel="agents"]')?.classList.contains('active');
                const conversationsTabActive = document.querySelector('.tab-panel[data-tab-panel="conversations"]')?.classList.contains('active');
                
                // Get subtab name for the active tab
                let subtabName = null;
                if (agentsTabActive) {
                    subtabName = getCurrentAgentsSubtab();
                } else if (conversationsTabActive) {
                    subtabName = getCurrentConversationsSubtab();
                }
                
                // Check content for each agent if we're on agents or conversations tab
                const agentContentChecks = {};
                if (subtabName) {
                    // For subtabs that have fields in the agents list, use those (already fetched)
                    if (subtabName === 'plans') {
                        agents.forEach(agent => {
                            agentContentChecks[agent.config_name] = agent.has_plans || false;
                        });
                    } else if (subtabName === 'memories') {
                        agents.forEach(agent => {
                            agentContentChecks[agent.config_name] = agent.has_memories || false;
                        });
                    } else if (subtabName === 'intentions') {
                        agents.forEach(agent => {
                            agentContentChecks[agent.config_name] = agent.has_intentions || false;
                        });
                    } else if (subtabName === 'notes-conv') {
                        // Conversations tab: Notes subtab
                        agents.forEach(agent => {
                            agentContentChecks[agent.config_name] = agent.has_notes || false;
                        });
                    } else if (subtabName === 'conversation-llm') {
                        // Conversations tab: Conversation LLM subtab
                        agents.forEach(agent => {
                            agentContentChecks[agent.config_name] = agent.has_conversation_llm || false;
                        });
                    } else {
                        // For other subtabs, call agentHasContent
                        await Promise.all(agents.map(async (agent) => {
                            agentContentChecks[agent.config_name] = await agentHasContent(agent.config_name, subtabName);
                        }));
                    }
                }
                
                // Fetch config directories once for the "New Agent" options
                let configDirs = [];
                try {
                    const configDirsResponse = await fetchWithAuth(`${API_BASE}/config-directories`);
                    const configDirsData = await configDirsResponse.json();
                    configDirs = configDirsData.directories || [];
                } catch (e) {
                    console.error('Error loading config directories:', e);
                }

                // Populate all agent selects
                ['agents-agent-select', 'conversations-agent-select'].forEach(selectId => {
                    const select = document.getElementById(selectId);
                    if (select) {
                        const currentValue = select.value;
                        select.innerHTML = '<option value="">Choose an agent...</option>';
                        
                        // Add "New Agent" entries for each config directory (only in agents tab)
                        if (selectId === 'agents-agent-select' && configDirs.length > 0) {
                            configDirs.forEach(dir => {
                                const option = document.createElement('option');
                                // Use dir.path if dir is an object, otherwise use dir itself
                                const path = (typeof dir === 'object') ? dir.path : dir;
                                const display = (typeof dir === 'object') ? dir.display_path : dir;
                                option.value = `NEW_AGENT|${path}`;
                                option.textContent = `+ New Agent in ${display}`;
                                option.style.fontWeight = 'bold';
                                option.style.color = '#28a745';
                                select.appendChild(option);
                            });
                            const divider = document.createElement('option');
                            divider.disabled = true;
                            divider.textContent = '────────────────────';
                            select.appendChild(divider);
                        }

                        agents.forEach(agent => {
                            const option = document.createElement('option');
                            option.value = agent.config_name;
                            // Display format: "Name (agent_id) [@username]" or "Name (agent_id)" or just "Name"
                            // Check explicitly for null/undefined to handle cases where agent_id is 0 (shouldn't happen for Telegram, but be safe)
                            let displayName = (agent.agent_id !== null && agent.agent_id !== undefined) 
                                ? `${agent.name} (${agent.agent_id})` 
                                : agent.name;
                            
                            // Add Telegram username if available
                            if (agent.telegram_username) {
                                displayName += ` [@${agent.telegram_username}]`;
                            }
                            
                            if (agent.is_disabled) {
                                displayName += ' (disabled)';
                                option.style.color = '#666';
                                option.style.fontStyle = 'italic';
                            }

                            // Add asterisk if agent has content for current subtab
                            // For agents tab: only show asterisk in agents-agent-select
                            // For conversations tab: only show asterisk in conversations-agent-select
                            if (subtabName && agentContentChecks[agent.config_name]) {
                                if ((selectId === 'agents-agent-select' && agentsTabActive) ||
                                    (selectId === 'conversations-agent-select' && conversationsTabActive)) {
                                    displayName += ' *';
                                }
                            }
                            option.textContent = displayName;
                            select.appendChild(option);
                        });
                        // When setting value, strip asterisk if present for comparison
                        if (currentValue) {
                            const strippedValue = stripAsterisk(currentValue);
                            select.value = strippedValue;
                        }
                    }
                });
            } catch (error) {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                console.error('Error loading agents:', error);
            }
        }

        // Set up agent select change handlers with synchronization
        document.getElementById('agents-agent-select')?.addEventListener('change', (e) => {
            const rawValue = e.target.value;
            if (rawValue.startsWith('NEW_AGENT|')) {
                const configDir = rawValue.split('|')[1];
                createNewAgent(configDir);
                // Reset select until creation is complete
                e.target.value = '';
                return;
            }

            const agentName = stripAsterisk(rawValue);
            
            // Synchronize with conversations agent select
            const conversationsSelect = document.getElementById('conversations-agent-select');
            const conversationsValue = conversationsSelect ? stripAsterisk(conversationsSelect.value) : '';
            if (conversationsSelect && conversationsValue !== agentName) {
                conversationsSelect.value = agentName;
                // Dispatch change event to trigger the change handler, which will clear containers and load partners
                conversationsSelect.dispatchEvent(new Event('change'));
            }
            
            if (agentName) {
                // Load data for the active subtab
                const activeSubtab = document.querySelector('.tab-panel[data-tab-panel="agents"] .tab-button.active');
                if (activeSubtab) {
                    const subtabName = activeSubtab.getAttribute('data-subtab');
                    if (subtabName === 'profile') {
                        loadAgentProfile(agentName);
                    } else if (subtabName === 'parameters') {
                        loadAgentConfiguration(agentName);
                    } else if (subtabName === 'memories') {
                        loadMemories(agentName);
                    } else if (subtabName === 'intentions') {
                        loadIntentions(agentName);
                    } else if (subtabName === 'documents-agent') {
                        loadAgentDocs(agentName);
                    } else if (subtabName === 'memberships') {
                        loadMemberships(agentName);
                    }
                }
            } else {
                // Agent selection cleared - hide profile section if profile subtab is active
                const activeSubtab = document.querySelector('.tab-panel[data-tab-panel="agents"] .tab-button.active');
                if (activeSubtab) {
                    const subtabName = activeSubtab.getAttribute('data-subtab');
                    if (subtabName === 'profile') {
                        loadAgentProfile('');
                    }
                }
            }
        });

        document.getElementById('recent-conversations-select')?.addEventListener('change', async (e) => {
            const value = e.target.value;
            if (!value) {
                return;
            }
            
            try {
                const convData = JSON.parse(value);
                const agentConfigName = convData.agent_config_name;
                const channelId = convData.channel_id;
                
                // Set agent select
                const agentSelect = document.getElementById('conversations-agent-select');
                if (agentSelect) {
                    agentSelect.value = agentConfigName;
                }
                
                // Synchronize with agents agent select
                const agentsSelect = document.getElementById('agents-agent-select');
                if (agentsSelect) {
                    agentsSelect.value = agentConfigName;
                }
                
                // Clear user-id input initially (will be set after partner selection)
                const userIdInput = document.getElementById('conversations-user-id');
                const partnerSelect = document.getElementById('conversations-partner-select');
                if (userIdInput) {
                    userIdInput.value = '';
                }
                if (partnerSelect) {
                    partnerSelect.value = '';
                }
                
                // Load conversation partners (this will populate the dropdown)
                if (agentConfigName) {
                    await loadConversationPartners(agentConfigName, 'conversations');
                    
                    // After partners are loaded, select the matching conversation
                    if (partnerSelect) {
                        // Find the option with matching channelId (strip asterisks for comparison)
                        const channelIdStr = String(channelId);
                        for (let i = 0; i < partnerSelect.options.length; i++) {
                            const option = partnerSelect.options[i];
                            const optionValue = stripAsterisk(option.value);
                            if (optionValue === channelIdStr) {
                                partnerSelect.value = option.value;
                                // Trigger change event to ensure consistency with user interaction
                                partnerSelect.dispatchEvent(new Event('change', { bubbles: true }));
                                return; // Exit early since change event will call loadConversationData
                            }
                        }
                    }
                }
                
                // If no matching partner was found in dropdown, set channelId as fallback
                if (userIdInput && channelId) {
                    userIdInput.value = channelId;
                }
                
                // Load the conversation data
                loadConversationData();
            } catch (error) {
                console.error('Error parsing recent conversation selection:', error);
            }
        });

        document.getElementById('conversations-agent-select')?.addEventListener('change', (e) => {
            const agentName = stripAsterisk(e.target.value);
            
            // Clear all conversation content containers when agent changes
            const conversationContainer = document.getElementById('conversation-container');
            if (conversationContainer) {
                conversationContainer.innerHTML = '<div class="loading">Select an agent and conversation partner</div>';
            }
            
            const notesContainer = document.getElementById('notes-conv-container');
            if (notesContainer) {
                notesContainer.innerHTML = '<div class="loading">Select an agent and conversation partner</div>';
            }
            
            const conversationLLMContainer = document.getElementById('conversation-llm-container');
            if (conversationLLMContainer) {
                conversationLLMContainer.innerHTML = '<div class="loading">Select an agent and conversation partner</div>';
            }
            
            const plansContainer = document.getElementById('plans-container');
            if (plansContainer) {
                plansContainer.innerHTML = '';
            }
            
            const xsendContainer = document.getElementById('xsend-container');
            if (xsendContainer) {
                // Reset xsend container to initial state: show loading, hide content
                const loadingDiv = xsendContainer.querySelector('.loading');
                if (loadingDiv) {
                    loadingDiv.style.display = 'block';
                    const xsendContent = document.getElementById('xsend-content');
                    if (xsendContent) {
                        xsendContent.style.display = 'none';
                    }
                    // Clear textarea value and status div content
                    const intentTextarea = document.getElementById('xsend-intent-textarea');
                    if (intentTextarea) {
                        intentTextarea.value = '';
                    }
                    const statusDiv = document.getElementById('xsend-status');
                    if (statusDiv) {
                        statusDiv.innerHTML = '';
                    }
                } else {
                    // If loading div doesn't exist (edge case), restore initial structure
                    xsendContainer.innerHTML = '<div class="loading">Select an agent and conversation partner</div><div style="margin-top: 16px; display: none;" id="xsend-content"><div class="directory-selector"><label for="xsend-intent-textarea">Intent:</label><br><textarea id="xsend-intent-textarea" placeholder="Enter the intent message..." style="width: 100%; min-height: 150px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; resize: vertical; box-sizing: border-box;"></textarea></div><div style="margin-top: 16px;"><button onclick="sendXSend()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">XSend</button><div id="xsend-status" style="margin-top: 8px; font-size: 14px;"></div></div></div>';
                }
            }
            
            // Clear partner select and user ID input
            const partnerSelect = document.getElementById('conversations-partner-select');
            if (partnerSelect) {
                partnerSelect.innerHTML = '<option value="">Select Conversation</option>';
            }
            
            const userIdInput = document.getElementById('conversations-user-id');
            if (userIdInput) {
                userIdInput.value = '';
            }
            
            // Reset recent conversations select to ensure consistency (selection may point to different agent)
            const recentConversationsSelect = document.getElementById('recent-conversations-select');
            if (recentConversationsSelect) {
                recentConversationsSelect.value = '';
            }
            
            // Synchronize with agents agent select
            const agentsSelect = document.getElementById('agents-agent-select');
            const agentsValue = agentsSelect ? stripAsterisk(agentsSelect.value) : '';
            if (agentsSelect && agentsValue !== agentName) {
                agentsSelect.value = agentName;
            }
            
            if (agentName) {
                loadConversationPartners(agentName, 'conversations');
            }
        });

        document.getElementById('conversations-partner-select')?.addEventListener('change', (e) => {
            document.getElementById('conversations-user-id').value = '';
            // Automatically load when partner is selected (only if non-empty)
            const userId = stripAsterisk(e.target.value);
            if (userId) {
                loadConversationData();
            }
        });

        async function loadConversationData() {
            const agentSelect = document.getElementById('conversations-agent-select');
            const partnerSelect = document.getElementById('conversations-partner-select');
            const userIdInput = document.getElementById('conversations-user-id');
            const agentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
            let userId = userIdInput?.value.trim() || (partnerSelect ? stripAsterisk(partnerSelect.value) : '');
            
            if (!agentName) {
                alert('Please select an agent');
                return;
            }
            
            if (!userId) {
                alert('Please enter/select a conversation partner');
                return;
            }
            
            // If userId is from text input and agent is selected, try to populate dropdowns
            const userIdFromInput = userIdInput?.value.trim();
            if (userIdFromInput && agentName) {
                // Ensure partners are loaded
                await loadConversationPartners(agentName, 'conversations');
                
                // Try to find matching conversation in dropdown
                // Check if userId is numeric (direct user ID match)
                const isNumeric = /^-?\d+$/.test(userIdFromInput);
                let foundMatch = false;
                if (isNumeric) {
                    // Find the option with matching user ID (strip asterisks for comparison)
                    for (let i = 0; i < partnerSelect.options.length; i++) {
                        const option = partnerSelect.options[i];
                        const optionValue = stripAsterisk(option.value);
                        if (optionValue === userIdFromInput) {
                            partnerSelect.value = option.value;
                            userIdInput.value = ''; // Clear input since we selected from dropdown
                            userId = optionValue; // Update userId for loading
                            foundMatch = true;
                            // Trigger change event to ensure consistency with user interaction
                            partnerSelect.dispatchEvent(new Event('change', { bubbles: true }));
                            return; // Exit early since change event will call loadConversationData
                        }
                    }
                } else {
                    // For username/phone, try to match by username in dropdown
                    // Usernames in dropdown are in format "Name (user_id) [@username]"
                    const usernameToMatch = userIdFromInput.startsWith('@') 
                        ? userIdFromInput.substring(1) 
                        : userIdFromInput;
                    
                    for (let i = 0; i < partnerSelect.options.length; i++) {
                        const option = partnerSelect.options[i];
                        const optionText = option.textContent;
                        // Check if option text contains [@username] matching our input
                        const usernameMatch = optionText.match(/\[@([^\]]+)\]/);
                        if (usernameMatch && usernameMatch[1].toLowerCase() === usernameToMatch.toLowerCase()) {
                            partnerSelect.value = option.value;
                            userIdInput.value = ''; // Clear input since we selected from dropdown
                            userId = stripAsterisk(option.value); // Update userId for loading
                            foundMatch = true;
                            // Trigger change event to ensure consistency with user interaction
                            partnerSelect.dispatchEvent(new Event('change', { bubbles: true }));
                            return; // Exit early since change event will call loadConversationData
                        }
                    }
                }
            }
            
            // Load data for the active subtab
            const activeSubtab = document.querySelector('.tab-panel[data-tab-panel="conversations"] .tab-button.active');
            if (activeSubtab) {
                const subtabName = activeSubtab.getAttribute('data-subtab');
                switchSubtab(subtabName);
            }
        }

        // Load memories
        function loadMemories(agentName) {
            const container = document.getElementById('memories-container');
            if (!container) return;
            
            // Validate that the agentName still matches the currently selected agent
            // This prevents stale data from being loaded if the user changed agents
            // during an async operation (e.g., loadAgents() updating the select)
            const agentSelect = document.getElementById('agents-agent-select');
            const currentAgentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
            if (currentAgentName !== agentName) {
                // Agent selection changed, don't load stale data
                return;
            }
            
            container.innerHTML = '<div class="loading">Loading memories...</div>';
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/memories`)
                .then(response => response.json())
                .then(data => {
                    // Validate again that agentName still matches the currently selected agent
                    // This prevents updating UI with stale data if user changed agents during the API call
                    const agentSelect = document.getElementById('agents-agent-select');
                    const currentAgentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
                    if (currentAgentName !== agentName) {
                        // Agent selection changed during API call, don't update UI with stale data
                        return;
                    }
                    
                    if (data.error) {
                        container.innerHTML = `<div class="error">Error: ${escapeHtml(data.error)}</div>`;
                        return;
                    }
                    
                    const memories = data.memories || [];
                    let html = '<div style="margin-bottom: 16px;"><button onclick="createNewMemory(\'' + escJsAttr(agentName) + '\')" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">+ Add New Memory</button></div>';
                    
                    if (memories.length === 0) {
                        html += '<div class="placeholder-card">No memories found.</div>';
                        container.innerHTML = html;
                        return;
                    }
                    
                    html += memories.map(memory => {
                        const metadata = [];
                        if (memory.creation_channel) {
                            metadata.push(`<strong>Channel:</strong> ${memory.creation_channel}`);
                        }
                        if (memory.creation_channel_id) {
                            metadata.push(`<strong>Channel ID:</strong> ${memory.creation_channel_id}`);
                        }
                        if (memory.origin) {
                            metadata.push(`<strong>Origin:</strong> ${memory.origin}`);
                        }
                        const metadataHtml = metadata.length > 0 ? '<br>' + metadata.join('<br>') : '';
                        
                        return `
                        <div class="memory-item" style="background: white; padding: 16px; margin-bottom: 16px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                                <div>
                                    <strong>ID:</strong> ${escapeHtml(memory.id || 'N/A')}<br>
                                    <strong>Created:</strong> ${escapeHtml(memory.created || 'N/A')}${metadataHtml}
                                </div>
                                <button onclick="deleteMemory('${escJsAttr(agentName)}', '${escJsAttr(memory.id)}')" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Delete</button>
                            </div>
                            <textarea 
                                id="memory-${memory.id}" 
                                style="width: 100%; min-height: 100px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; resize: vertical; box-sizing: border-box;"
                                oninput="scheduleMemoryAutoSave('${escJsAttr(agentName)}', '${escJsAttr(memory.id)}')"
                            >${escapeHtml(memory.content || '')}</textarea>
                            <div id="memory-status-${memory.id}" style="margin-top: 8px; font-size: 12px; color: #28a745;">Saved</div>
                        </div>
                    `;
                    }).join('');
                    container.innerHTML = html;
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    // Validate that agentName still matches the currently selected agent
                    // This prevents updating UI with stale error data if user changed agents during the API call
                    const agentSelect = document.getElementById('agents-agent-select');
                    const currentAgentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
                    if (currentAgentName !== agentName) {
                        // Agent selection changed during API call, don't update UI with stale error data
                        return;
                    }
                    container.innerHTML = `<div class="error">Error loading memories: ${escapeHtml(error)}</div>`;
                });
        }

        function createNewMemory(agentName) {
            if (!agentName) {
                alert('Please select an agent');
                return;
            }
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/memories`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ content: 'New memory entry' })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error creating memory: ' + data.error);
                } else {
                    loadMemories(agentName);
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error creating memory: ' + error);
            });
        }

        // Auto-save for memories
        const memoryAutoSaveTimers = {};
        function scheduleMemoryAutoSave(agentName, memoryId) {
            if (memoryAutoSaveTimers[memoryId]) {
                clearTimeout(memoryAutoSaveTimers[memoryId]);
            }
            
            const statusEl = document.getElementById(`memory-status-${memoryId}`);
            if (statusEl) {
                statusEl.textContent = 'Typing...';
                statusEl.style.color = '#007bff';
            }
            
            memoryAutoSaveTimers[memoryId] = setTimeout(() => {
                const textarea = document.getElementById(`memory-${memoryId}`);
                if (!textarea) {
                    return; // Element no longer exists
                }
                const content = textarea.value.trim();
                
                const statusEl = document.getElementById(`memory-status-${memoryId}`);
                if (statusEl) {
                    statusEl.textContent = 'Saving...';
                    statusEl.style.color = '#007bff';
                }
                
                fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/memories/${memoryId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ content: content })
                })
                .then(response => response.json())
                .then(data => {
                    const statusEl = document.getElementById(`memory-status-${memoryId}`);
                    if (statusEl) {
                        if (data.error) {
                            statusEl.textContent = 'Error';
                            statusEl.style.color = '#dc3545';
                        } else {
                            statusEl.textContent = 'Saved';
                            statusEl.style.color = '#28a745';
                        }
                    }
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    const statusEl = document.getElementById(`memory-status-${memoryId}`);
                    if (statusEl) {
                        statusEl.textContent = 'Error';
                        statusEl.style.color = '#dc3545';
                    }
                });
            }, 1000);
        }

        function deleteMemory(agentName, memoryId) {
            if (!confirm('Are you sure you want to delete this memory?')) {
                return;
            }
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/memories/${memoryId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error deleting memory: ' + data.error);
                } else {
                    loadMemories(agentName);
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error deleting memory: ' + error);
            });
        }


        // Auto-save for notes
        const noteAutoSaveTimers = {};
        function scheduleNoteAutoSave(agentName, userId, noteId) {
            const key = `${agentName}-${userId}-${noteId}`;
            if (noteAutoSaveTimers[key]) {
                clearTimeout(noteAutoSaveTimers[key]);
            }
            
            const statusEl = document.getElementById(`note-status-${userId}-${noteId}`);
            if (statusEl) {
                statusEl.textContent = 'Typing...';
                statusEl.style.color = '#007bff';
            }
            
            noteAutoSaveTimers[key] = setTimeout(() => {
                // Try both possible textarea ID formats (Agents tab and Conversations tab)
                let textarea = document.getElementById(`note-${userId}-${noteId}`);
                if (!textarea) {
                    textarea = document.getElementById(`note-params-${userId}-${noteId}`);
                }
                if (!textarea) {
                    return; // Element no longer exists
                }
                const content = textarea.value.trim();
                
                const statusEl = document.getElementById(`note-status-${userId}-${noteId}`);
                if (statusEl) {
                    statusEl.textContent = 'Saving...';
                    statusEl.style.color = '#007bff';
                }
                
                fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/notes/${userId}/${noteId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ content: content })
                })
                .then(response => response.json())
                .then(data => {
                    const statusEl = document.getElementById(`note-status-${userId}-${noteId}`);
                    if (statusEl) {
                        if (data.error) {
                            statusEl.textContent = 'Error';
                            statusEl.style.color = '#dc3545';
                        } else {
                            statusEl.textContent = 'Saved';
                            statusEl.style.color = '#28a745';
                        }
                    }
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    const statusEl = document.getElementById(`note-status-${userId}-${noteId}`);
                    if (statusEl) {
                        statusEl.textContent = 'Error';
                        statusEl.style.color = '#dc3545';
                    }
                });
            }, 1000);
        }

        function deleteNote(agentName, userId, noteId) {
            if (!confirm('Are you sure you want to delete this note?')) {
                return;
            }
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/notes/${userId}/${noteId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error deleting note: ' + data.error);
                } else {
                    loadNotesForPartner();
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error deleting note: ' + error);
            });
        }

        // Load intentions (similar to memories)
        function loadIntentions(agentName) {
            const container = document.getElementById('intentions-container');
            container.innerHTML = '<div class="loading">Loading intentions...</div>';
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/intentions`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        container.innerHTML = `<div class="error">Error: ${escapeHtml(data.error)}</div>`;
                        return;
                    }
                    
                    const intentions = data.intentions || [];
                    let html = '<div style="margin-bottom: 16px;"><button onclick="createNewIntention(\'' + escJsAttr(agentName) + '\')" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">+ Add New Intention</button></div>';
                    
                    if (intentions.length === 0) {
                        html += '<div class="placeholder-card">No intentions found.</div>';
                        container.innerHTML = html;
                        return;
                    }
                    
                    html += intentions.map(intention => `
                        <div class="memory-item" style="background: white; padding: 16px; margin-bottom: 16px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                                <div>
                                    <strong>ID:</strong> ${escapeHtml(intention.id || 'N/A')}<br>
                                    <strong>Created:</strong> ${escapeHtml(intention.created || 'N/A')}
                                </div>
                                <button onclick="deleteIntention('${escJsAttr(agentName)}', '${escJsAttr(intention.id)}')" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Delete</button>
                            </div>
                            <textarea 
                                id="intention-${intention.id}" 
                                style="width: 100%; min-height: 100px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; resize: vertical; box-sizing: border-box;"
                                oninput="scheduleIntentionAutoSave('${escJsAttr(agentName)}', '${escJsAttr(intention.id)}')"
                            >${escapeHtml(intention.content || '')}</textarea>
                            <div id="intention-status-${intention.id}" style="margin-top: 8px; font-size: 12px; color: #28a745;">Saved</div>
                        </div>
                    `).join('');
                    container.innerHTML = html;
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    container.innerHTML = `<div class="error">Error loading intentions: ${escapeHtml(error)}</div>`;
                });
        }

        function createNewIntention(agentName) {
            if (!agentName) {
                alert('Please select an agent');
                return;
            }
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/intentions`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ content: 'New intention entry' })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error creating intention: ' + data.error);
                } else {
                    loadIntentions(agentName);
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error creating intention: ' + error);
            });
        }

        // Auto-save for intentions
        const intentionAutoSaveTimers = {};
        function scheduleIntentionAutoSave(agentName, intentionId) {
            if (intentionAutoSaveTimers[intentionId]) {
                clearTimeout(intentionAutoSaveTimers[intentionId]);
            }
            
            const statusEl = document.getElementById(`intention-status-${intentionId}`);
            if (statusEl) {
                statusEl.textContent = 'Typing...';
                statusEl.style.color = '#007bff';
            }
            
            intentionAutoSaveTimers[intentionId] = setTimeout(() => {
                const textarea = document.getElementById(`intention-${intentionId}`);
                const content = textarea.value.trim();
                
                if (statusEl) {
                    statusEl.textContent = 'Saving...';
                    statusEl.style.color = '#007bff';
                }
                
                fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/intentions/${intentionId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ content: content })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        if (statusEl) {
                            statusEl.textContent = 'Error';
                            statusEl.style.color = '#dc3545';
                        }
                    } else {
                        if (statusEl) {
                            statusEl.textContent = 'Saved';
                            statusEl.style.color = '#28a745';
                        }
                    }
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    if (statusEl) {
                        statusEl.textContent = 'Error';
                        statusEl.style.color = '#dc3545';
                    }
                });
            }, 1000);
        }

        function deleteIntention(agentName, intentionId) {
            if (!confirm('Are you sure you want to delete this intention?')) {
                return;
            }
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/intentions/${intentionId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error deleting intention: ' + data.error);
                } else {
                    loadIntentions(agentName);
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error deleting intention: ' + error);
            });
        }

        // Load memberships
        function loadMemberships(agentName) {
            const container = document.getElementById('memberships-container');
            if (!container) return;
            
            // Validate that the agentName still matches the currently selected agent
            const agentSelect = document.getElementById('agents-agent-select');
            const currentAgentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
            if (currentAgentName !== agentName) {
                return;
            }
            
            if (!agentName) {
                container.innerHTML = '<div class="loading">Select an agent to manage memberships</div>';
                return;
            }
            
            container.innerHTML = '<div class="loading">Loading memberships...</div>';
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/memberships`)
                .then(response => response.json())
                .then(data => {
                    // Re-validate agent name after async operation
                    const agentSelect = document.getElementById('agents-agent-select');
                    const currentAgentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
                    if (currentAgentName !== agentName) {
                        return;
                    }
                    
                    if (data.error) {
                        container.innerHTML = `<div class="error">Error: ${escapeHtml(data.error)}</div>`;
                        return;
                    }
                    
                    const memberships = data.memberships || [];
                    
                    let html = '<div style="margin-bottom: 20px;">';
                    html += '<div style="display: flex; gap: 8px; align-items: center; margin-bottom: 16px;">';
                    html += '<input type="text" id="membership-identifier" placeholder="Group username, ID, or invitation link" style="flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;" onkeypress="if(event.key===\'Enter\') subscribeToGroup(\'' + escJsAttr(agentName) + '\')">';
                    html += '<button id="membership-subscribe-btn" onclick="subscribeToGroup(\'' + escJsAttr(agentName) + '\')" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Subscribe</button>';
                    html += '</div>';
                    html += '</div>';
                    
                    if (memberships.length === 0) {
                        html += '<div style="padding: 20px; text-align: center; color: #666;">No group memberships found</div>';
                    } else {
                        html += '<div style="display: grid; gap: 12px;">';
                        memberships.forEach(membership => {
                            const name = membership.name || 'Unknown';
                            const channelId = membership.channel_id;
                            const username = membership.username ? `@${membership.username}` : '';
                            const isMuted = membership.is_muted || false;
                            
                            html += '<div style="padding: 16px; background: #ffffff; border: 1px solid #e0e0e0; border-radius: 4px; display: flex; align-items: center; gap: 12px;">';
                            html += '<div style="flex: 1; min-width: 0;">';
                            html += '<div style="font-weight: 500; margin-bottom: 4px;">' + escapeHtml(name) + '</div>';
                            html += '<div style="font-size: 12px; color: #666;">';
                            html += 'ID: ' + escapeHtml(channelId);
                            if (username) {
                                html += ' • ' + escapeHtml(username);
                            }
                            html += '</div>';
                            html += '</div>';
                            html += '<div style="display: flex; align-items: center; gap: 8px;">';
                            html += '<label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">';
                            html += '<input type="checkbox" ' + (isMuted ? 'checked' : '') + ' onchange="toggleMuteMembership(\'' + escJsAttr(agentName) + '\', \'' + escJsAttr(channelId) + '\', this.checked)" style="cursor: pointer;">';
                            html += '<span style="font-size: 14px;">Muted</span>';
                            html += '</label>';
                            html += '<button onclick="deleteMembership(\'' + escJsAttr(agentName) + '\', \'' + escJsAttr(channelId) + '\', \'' + escJsAttr(name) + '\')" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Delete</button>';
                            html += '</div>';
                            html += '</div>';
                        });
                        html += '</div>';
                    }
                    
                    container.innerHTML = html;
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    container.innerHTML = `<div class="error">Error loading memberships: ${escapeHtml(error)}</div>`;
                });
        }

        function subscribeToGroup(agentName) {
            const identifierInput = document.getElementById('membership-identifier');
            if (!identifierInput) return;
            
            const identifier = identifierInput.value.trim();
            if (!identifier) {
                alert('Please enter a group username, ID, or invitation link');
                return;
            }
            
            const button = document.getElementById('membership-subscribe-btn');
            if (button) {
                button.disabled = true;
                button.textContent = 'Subscribing...';
            }
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/memberships/subscribe`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ identifier: identifier })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error subscribing: ' + data.error);
                } else {
                    // Clear input
                    identifierInput.value = '';
                    // Show warning if present (e.g., join succeeded but mute failed)
                    if (data.warning) {
                        alert('Warning: ' + data.warning);
                    }
                    // Reload memberships
                    loadMemberships(agentName);
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error subscribing: ' + error);
            })
            .finally(() => {
                if (button) {
                    button.disabled = false;
                    button.textContent = 'Subscribe';
                }
            });
        }

        function toggleMuteMembership(agentName, channelId, isMuted) {
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/memberships/${encodeURIComponent(channelId)}/mute`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ is_muted: isMuted })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error toggling mute: ' + data.error);
                    // Reload to restore correct state
                    loadMemberships(agentName);
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error toggling mute: ' + error);
                // Reload to restore correct state
                loadMemberships(agentName);
            });
        }

        function deleteMembership(agentName, channelId, name) {
            const displayName = name || channelId;
            const escapedDisplayName = escJsTemplate(displayName);
            if (!confirm(`Are you sure you want to delete the subscription to "${escapedDisplayName}"?`)) {
                return;
            }
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/memberships/${encodeURIComponent(channelId)}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error deleting subscription: ' + data.error);
                } else {
                    loadMemberships(agentName);
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error deleting subscription: ' + error);
            });
        }

        // Load agent configuration
        // Profile management variables
        let currentAgentProfile = null;
        let originalAgentProfile = null;
        let bioLimit = 70;
        let expectedProfileAgent = null; // Track which agent we're expecting a profile response for

        // Profile photo fullscreen functions
        function showProfilePhotoFullscreen() {
            const photo = document.getElementById('agent-profile-photo');
            const fullscreenPhoto = document.getElementById('profile-photo-fullscreen');
            const modal = document.getElementById('profile-photo-modal');
            if (photo && photo.src && photo.src !== '') {
                fullscreenPhoto.src = photo.src;
                modal.style.display = 'block';
            }
        }

        function closeProfilePhotoFullscreen() {
            const modal = document.getElementById('profile-photo-modal');
            modal.style.display = 'none';
        }

        // Escape key to close fullscreen photo
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeProfilePhotoFullscreen();
            }
        });

        // Update birthday day options based on selected month
        function updateBirthdayDays() {
            const monthSelect = document.getElementById('agent-profile-birthday-month');
            const daySelect = document.getElementById('agent-profile-birthday-day');
            const month = monthSelect.value ? parseInt(monthSelect.value) : null;
            
            // Preserve current day selection if it exists
            const currentDay = daySelect.value ? parseInt(daySelect.value) : null;
            
            // Clear existing options
            daySelect.innerHTML = '<option value="">Day</option>';
            
            // If month is cleared, also clear day selection and show cancel button
            if (!month) {
                daySelect.value = '';
                // Enable cancel button since we made a change
                document.getElementById('agent-profile-cancel-btn').style.display = 'inline-block';
                return;
            }
            
            // Days in each month (using 29 for February to handle leap years)
            const daysInMonth = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            const days = daysInMonth[month - 1];
            
            for (let i = 1; i <= days; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                daySelect.appendChild(option);
            }
            
            // Restore day selection if it's valid for the new month
            // If the previous day is too high for the new month (e.g., 31 -> February),
            // clamp it to the maximum valid day
            if (currentDay !== null) {
                if (currentDay <= days) {
                    daySelect.value = currentDay;
                } else {
                    // Day is too high for new month, clamp to max valid day
                    daySelect.value = days;
                }
            }
            
            // Enable cancel button since we made a change
            document.getElementById('agent-profile-cancel-btn').style.display = 'inline-block';
        }

        // Validate bio character count
        function validateBio() {
            const bioTextarea = document.getElementById('agent-profile-bio');
            const statusDiv = document.getElementById('agent-profile-bio-status');
            const saveBtn = document.getElementById('agent-profile-save-btn');
            const bio = bioTextarea.value;
            const currentLength = bio.length;
            
            if (currentLength > bioLimit) {
                statusDiv.textContent = `Bio exceeds limit by ${currentLength - bioLimit} characters (max ${bioLimit})`;
                statusDiv.style.color = '#dc3545';
                bioTextarea.style.borderColor = '#dc3545';
                saveBtn.disabled = true;
            } else {
                const remaining = bioLimit - currentLength;
                statusDiv.textContent = `${remaining} characters remaining (max ${bioLimit})`;
                statusDiv.style.color = remaining < 20 ? '#ffc107' : '#28a745';
                bioTextarea.style.borderColor = '#28a745';
                saveBtn.disabled = false;
            }
        }

        // Load agent profile
        async function loadAgentProfile(agentName) {
            const profileSection = document.getElementById('agent-profile-section');
            const profileContainer = document.getElementById('profile-container');
            
            if (!agentName) {
                if (profileSection) {
                    profileSection.style.display = 'none';
                }
                if (profileContainer) {
                    profileContainer.style.display = 'block';
                }
                expectedProfileAgent = null;
                return;
            }

            // Show profile section (this function is only called when profile subtab is active)
            if (profileSection) {
                profileSection.style.display = 'block';
            }
            // Hide placeholder container when loading profile
            if (profileContainer) {
                profileContainer.style.display = 'none';
            }
            
            // Track which agent we're loading for
            expectedProfileAgent = agentName;
            
            try {
                const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/profile`);
                const data = await response.json();
                
                if (data.error) {
                    // Only handle error if this request is still relevant
                    if (expectedProfileAgent !== agentName) {
                        return;
                    }
                    if (response.status === 400 && data.error.includes('not authenticated')) {
                        // Agent not authenticated - hide profile section or show message
                        if (profileSection) {
                            profileSection.style.display = 'none';
                        }
                        if (profileContainer) {
                            profileContainer.style.display = 'block';
                        }
                        expectedProfileAgent = null;
                        return;
                    }
                    console.error('Error loading profile:', data.error);
                    if (profileSection) {
                        profileSection.style.display = 'none';
                    }
                    if (profileContainer) {
                        profileContainer.style.display = 'block';
                    }
                    expectedProfileAgent = null;
                    return;
                }
                
                // Verify this response is still relevant (user may have switched agents)
                // Check both expectedProfileAgent and the currently selected agent
                if (expectedProfileAgent !== agentName) {
                    // This response is for a different agent, ignore it
                    return;
                }
                const agentSelect = document.getElementById('agents-agent-select');
                const currentSelectedAgent = agentSelect ? stripAsterisk(agentSelect.value) : null;
                if (currentSelectedAgent !== agentName) {
                    // Agent changed while loading, ignore this response
                    return;
                }
                
                // Store original and current profile
                originalAgentProfile = JSON.parse(JSON.stringify(data));
                currentAgentProfile = data;
                bioLimit = data.bio_limit || 70;
                
                // Populate form fields
                document.getElementById('agent-profile-first-name').value = data.first_name || '';
                document.getElementById('agent-profile-last-name').value = data.last_name || '';
                document.getElementById('agent-profile-username').value = data.username || '';
                document.getElementById('agent-profile-telegram-id').value = data.telegram_id || '';
                document.getElementById('agent-profile-bio').value = data.bio || '';
                
                // Set profile photo
                const photoImg = document.getElementById('agent-profile-photo');
                if (data.profile_photo) {
                    photoImg.src = data.profile_photo;
                    photoImg.style.display = 'block';
                } else {
                    photoImg.src = '';
                    photoImg.style.display = 'none';
                }
                
                // Set birthday
                const monthSelect = document.getElementById('agent-profile-birthday-month');
                const daySelect = document.getElementById('agent-profile-birthday-day');
                const yearInput = document.getElementById('agent-profile-birthday-year');
                
                monthSelect.value = '';
                daySelect.innerHTML = '<option value="">Day</option>';
                yearInput.value = '';
                
                if (data.birthday) {
                    monthSelect.value = data.birthday.month || '';
                    updateBirthdayDays();
                    if (data.birthday.day) {
                        daySelect.value = data.birthday.day;
                    }
                    if (data.birthday.year) {
                        yearInput.value = data.birthday.year;
                    }
                }
                
                // Validate bio
                validateBio();
                
                // Hide cancel button
                document.getElementById('agent-profile-cancel-btn').style.display = 'none';
                document.getElementById('agent-profile-save-status').textContent = '';
                
            } catch (error) {
                // Only log error if this request is still relevant
                if (expectedProfileAgent === agentName) {
                    console.error('Error loading agent profile:', error);
                    // Restore UI state on network/parsing errors
                    if (profileSection) {
                        profileSection.style.display = 'none';
                    }
                    if (profileContainer) {
                        profileContainer.style.display = 'block';
                    }
                    expectedProfileAgent = null;
                }
            }
        }

        // Save agent profile
        async function saveAgentProfile() {
            const agentSelect = document.getElementById('agents-agent-select');
            const agentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
            
            if (!agentName) {
                alert('No agent selected');
                return;
            }
            
            // Verify the profile data matches the selected agent
            // This prevents saving stale data from a previously selected agent
            if (expectedProfileAgent !== null && expectedProfileAgent !== agentName) {
                alert('Agent selection changed. Please reload the profile and try again.');
                return;
            }
            
            const saveBtn = document.getElementById('agent-profile-save-btn');
            const statusDiv = document.getElementById('agent-profile-save-status');
            const cancelBtn = document.getElementById('agent-profile-cancel-btn');
            
            saveBtn.disabled = true;
            statusDiv.textContent = 'Saving...';
            statusDiv.style.color = '#007bff';
            
            try {
                // Collect form data
                const first_name = document.getElementById('agent-profile-first-name').value.trim();
                const last_name = document.getElementById('agent-profile-last-name').value.trim();
                const username = document.getElementById('agent-profile-username').value.trim().replace(/^@/, '');
                const bio = document.getElementById('agent-profile-bio').value;
                
                // Collect birthday
                const monthSelect = document.getElementById('agent-profile-birthday-month');
                const daySelect = document.getElementById('agent-profile-birthday-day');
                const yearInput = document.getElementById('agent-profile-birthday-year');
                
                const monthValue = monthSelect.value.trim();
                const dayValue = daySelect.value.trim();
                const yearValue = yearInput.value.trim();
                
                // Validate birthday: if month is selected, day is required
                if (monthValue && !dayValue) {
                    statusDiv.textContent = 'Error: Please select a day when a month is selected';
                    statusDiv.style.color = '#dc3545';
                    saveBtn.disabled = false;
                    // Highlight the day field
                    daySelect.style.borderColor = '#dc3545';
                    // Clear highlight after 3 seconds
                    setTimeout(() => {
                        daySelect.style.borderColor = '#ddd';
                    }, 3000);
                    return;
                }
                
                // If month is empty, birthday should be null (removed)
                // Otherwise, both month and day are required (validated above)
                let birthday = null;
                if (monthValue && dayValue) {
                    const month = parseInt(monthValue);
                    const day = parseInt(dayValue);
                    const year = yearValue ? parseInt(yearValue) : null;
                    
                    birthday = {
                        day: day,
                        month: month,
                        year: year  // Can be null (optional)
                    };
                }
                // If month is empty, birthday remains null (birthday will be removed)
                
                // Validate bio length
                if (bio.length > bioLimit) {
                    statusDiv.textContent = `Error: Bio exceeds limit of ${bioLimit} characters`;
                    statusDiv.style.color = '#dc3545';
                    saveBtn.disabled = false;
                    return;
                }
                
                const updateData = {
                    first_name: first_name,
                    last_name: last_name,
                    username: username,
                    bio: bio,
                    birthday: birthday
                };
                
                const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/profile`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });
                
                const data = await response.json();
                
                if (data.error) {
                    statusDiv.textContent = `Error: ${data.error}`;
                    statusDiv.style.color = '#dc3545';
                    saveBtn.disabled = false;
                    return;
                }
                
                // Success - reload profile to get updated data (especially profile photo)
                await loadAgentProfile(agentName);
                
                // Refresh agent list to update username in pulldown selectors
                await loadAgents();
                
                statusDiv.textContent = 'Profile saved successfully';
                statusDiv.style.color = '#28a745';
                cancelBtn.style.display = 'none';
                
                // Clear status message after 3 seconds
                setTimeout(() => {
                    statusDiv.textContent = '';
                }, 3000);
                
            } catch (error) {
                console.error('Error saving profile:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.style.color = '#dc3545';
            } finally {
                saveBtn.disabled = false;
            }
        }

        // Cancel profile edit
        function cancelAgentProfileEdit() {
            if (originalAgentProfile) {
                // Restore original values
                document.getElementById('agent-profile-first-name').value = originalAgentProfile.first_name || '';
                document.getElementById('agent-profile-last-name').value = originalAgentProfile.last_name || '';
                document.getElementById('agent-profile-username').value = originalAgentProfile.username || '';
                document.getElementById('agent-profile-bio').value = originalAgentProfile.bio || '';
                
                // Restore birthday
                const monthSelect = document.getElementById('agent-profile-birthday-month');
                const daySelect = document.getElementById('agent-profile-birthday-day');
                const yearInput = document.getElementById('agent-profile-birthday-year');
                
                monthSelect.value = '';
                daySelect.innerHTML = '<option value="">Day</option>';
                yearInput.value = '';
                
                if (originalAgentProfile.birthday) {
                    monthSelect.value = originalAgentProfile.birthday.month || '';
                    updateBirthdayDays();
                    if (originalAgentProfile.birthday.day) {
                        daySelect.value = originalAgentProfile.birthday.day;
                    }
                    if (originalAgentProfile.birthday.year) {
                        yearInput.value = originalAgentProfile.birthday.year;
                    }
                }
                
                validateBio();
                document.getElementById('agent-profile-cancel-btn').style.display = 'none';
                document.getElementById('agent-profile-save-status').textContent = '';
            }
        }

        // Set up birthday month change handler
        document.addEventListener('DOMContentLoaded', () => {
            const monthSelect = document.getElementById('agent-profile-birthday-month');
            if (monthSelect) {
                monthSelect.addEventListener('change', updateBirthdayDays);
            }
            
            // Track changes to enable cancel button
            const profileFields = [
                'agent-profile-first-name',
                'agent-profile-last-name',
                'agent-profile-username',
                'agent-profile-bio',
                'agent-profile-birthday-month',
                'agent-profile-birthday-day',
                'agent-profile-birthday-year'
            ];
            
            profileFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', () => {
                        document.getElementById('agent-profile-cancel-btn').style.display = 'inline-block';
                    });
                    field.addEventListener('change', () => {
                        document.getElementById('agent-profile-cancel-btn').style.display = 'inline-block';
                    });
                }
            });
        });

        function loadAgentConfiguration(agentName) {
            const container = document.getElementById('parameters-container');
            container.innerHTML = '<div class="loading">Loading configuration...</div>';
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        container.innerHTML = `<div class="error">Error: ${escapeHtml(data.error)}</div>`;
                        return;
                    }
                    
                    const currentLLM = data.llm || '';
                    const availableLLMs = data.available_llms || [];
                    const prompt = data.prompt || '';
                    const currentTimezone = data.timezone || '';
                    const availableTimezones = data.available_timezones || [];
                    const isDisabled = data.is_disabled || false;
                    
                    // New fields
                    const phone = data.phone || '';
                    const rolePromptNames = data.role_prompt_names || [];
                    const availableRolePrompts = data.available_role_prompts || [];
                    const stickerSetNames = data.sticker_set_names || [];
                    const explicitStickers = data.explicit_stickers || [];
                    const dailyScheduleDescription = data.daily_schedule_description;
                    const resetContextOnFirstMessage = data.reset_context_on_first_message || false;
                    const startTypingDelay = data.start_typing_delay !== undefined ? data.start_typing_delay : null;
                    const typingSpeed = data.typing_speed !== undefined ? data.typing_speed : null;
                    const configDirectory = data.config_directory || '';
                    const availableConfigDirectories = data.available_config_directories || [];
                    
                    container.innerHTML = `
                        <div style="background: white; padding: 16px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div class="agent-status-header">
                                <div>
                                    <h3 style="margin: 0;">Agent Status</h3>
                                    <div class="agent-status-actions">
                                        <button id="toggle-agent-button" onclick="toggleAgentDisabled('${escJsAttr(agentName)}', ${!isDisabled})" style="padding: 8px 16px; background: ${isDisabled ? '#28a745' : '#6c757d'}; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                                            ${isDisabled ? 'Enable Agent' : 'Disable Agent'}
                                        </button>
                                        ${isDisabled ? `
                                            <button onclick="deleteAgent('${escJsAttr(agentName)}', '${escJsAttr(data.name || agentName)}')" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                                Delete Agent
                                            </button>
                                        ` : ''}
                                    </div>
                                </div>
                                <div class="agent-status-info">
                                    <div style="font-size: 12px; color: #666;">
                                        Config Name (filename):
                                        ${isDisabled ? 
                                            `<input type="text" value="${escapeHtml(agentName)}" 
                                                style="font-size: 12px; padding: 2px 4px; border: 1px solid #ccc; border-radius: 4px; width: 150px;"
                                                onchange="renameAgentConfig('${escJsAttr(agentName)}', this.value)">` : 
                                            `<strong>${escapeHtml(agentName)}</strong>`
                                        }
                                    </div>
                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                        Config Directory:
                                        ${isDisabled ? 
                                            `<select id="agent-config-directory-select" 
                                                style="font-size: 12px; padding: 2px 4px; border: 1px solid #ccc; border-radius: 4px; width: 200px; margin-left: 4px;"
                                                onchange="moveAgentConfigDirectory('${escJsAttr(agentName)}', this.value, '${escJsAttr(configDirectory)}')">
                                                ${availableConfigDirectories.map(dir => 
                                                    `<option value="${escapeHtml(dir.value)}" ${dir.value === configDirectory ? 'selected' : ''}>${escapeHtml(dir.label)}</option>`
                                                ).join('')}
                                            </select>` : 
                                            `<strong>${escapeHtml(configDirectory || 'Unknown')}</strong>`
                                        }
                                    </div>
                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">Status: <span style="color: ${isDisabled ? '#dc3545' : '#28a745'}; font-weight: bold;">${isDisabled ? 'Disabled' : 'Enabled'}</span></div>
                                </div>
                            </div>

                            <div class="agent-param-grid">
                                <div class="agent-param-section">
                                    <h3>Agent Name (display)</h3>
                                    <input id="agent-name-input" type="text" class="agent-param-input" value="${escapeHtml(data.name || '')}" ${!isDisabled ? 'disabled' : ''} 
                                        onchange="updateAgentName('${escJsAttr(agentName)}', this.value)">
                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">Display name used in the console</div>
                                </div>
                                <div class="agent-param-section">
                                    <h3>Agent Phone</h3>
                                    <input id="agent-phone-input" type="text" class="agent-param-input" value="${escapeHtml(phone)}" ${!isDisabled ? 'disabled' : ''} 
                                        onchange="updateAgentPhone('${escJsAttr(agentName)}', this.value)">
                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">E.164 format, e.g., +1234567890</div>
                                </div>
                            </div>
                            
                            <div class="agent-param-grid">
                                <div class="agent-param-section">
                                    <h3>Agent LLM</h3>
                                    <select id="agent-llm-select" class="agent-param-input" onchange="updateAgentLLM('${escJsAttr(agentName)}', this.value)">
                                        ${availableLLMs.map(llm => {
                                            return `<option value="${escapeHtml(llm.value)}" ${llm.value === currentLLM ? 'selected' : ''}>${escapeHtml(llm.label)}${llm.is_default ? ' *' : ''}</option>`;
                                        }).join('')}
                                    </select>
                                </div>
                            </div>

                            <div class="agent-param-section">
                                <h3>Role Prompts</h3>
                                <div id="role-prompts-list" class="role-prompts-container">
                                    ${rolePromptNames.length > 0 ? rolePromptNames.map(name => `
                                        <div class="role-prompt-tag">
                                            <span>${escapeHtml(name)}</span>
                                            ${isDisabled ? `<button onclick="removeRolePrompt('${escJsAttr(agentName)}', '${escJsAttr(name)}')">&times;</button>` : ''}
                                        </div>
                                    `).join('') : '<div style="color: #666; font-style: italic; font-size: 14px;">No role prompts selected</div>'}
                                </div>
                                <select id="available-role-prompts-select" ${!isDisabled ? 'disabled' : ''} 
                                    onchange="if(this.value) addRolePrompt('${escJsAttr(agentName)}', this.value); this.value='';" 
                                    class="agent-param-input" style="min-width: 200px; width: auto;">
                                    <option value="">Add role prompt...</option>
                                    ${availableRolePrompts.filter(p => !rolePromptNames.includes(p)).map(p => `<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`).join('')}
                                </select>
                            </div>

                            <div class="agent-param-grid">
                                <div class="agent-param-section">
                                    <h3>Sticker Sets</h3>
                                    <textarea id="agent-sticker-sets-textarea" ${!isDisabled ? 'disabled' : ''} 
                                        onchange="updateAgentStickers('${escJsAttr(agentName)}')" 
                                        class="agent-param-textarea" style="min-height: 80px;"
                                        placeholder="One set name per line, e.g.\nWendyDancer\nCindyAI"
                                    >${escapeHtml(stickerSetNames.join('\n'))}</textarea>
                                </div>
                                <div class="agent-param-section">
                                    <h3>Explicit Stickers</h3>
                                    <textarea id="agent-explicit-stickers-textarea" ${!isDisabled ? 'disabled' : ''} 
                                        onchange="updateAgentStickers('${escJsAttr(agentName)}')" 
                                        class="agent-param-textarea" style="min-height: 80px;"
                                        placeholder="SET :: STICKER per line, e.g.\nWendyDancer :: Wink\nCindyAI :: Hello"
                                    >${escapeHtml(explicitStickers.join('\n'))}</textarea>
                                </div>
                            </div>

                            <div class="agent-param-section">
                                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                                    <h3 style="margin: 0;">Daily Schedule</h3>
                                    <label class="agent-param-checkbox-label">
                                        <input type="checkbox" id="daily-schedule-enabled" ${dailyScheduleDescription !== null ? 'checked' : ''} ${!isDisabled ? 'disabled' : ''} 
                                            onchange="updateAgentDailySchedule('${escJsAttr(agentName)}')">
                                        Enabled
                                    </label>
                                </div>
                                <textarea id="daily-schedule-textarea" ${!isDisabled ? 'disabled' : ''} 
                                    onchange="updateAgentDailySchedule('${escJsAttr(agentName)}')" 
                                    class="agent-param-textarea" style="min-height: 60px; ${dailyScheduleDescription === null ? 'background: #f8f9fa; color: #999;' : ''}"
                                    placeholder="Freeform English description of the daily schedule..."
                                >${escapeHtml(dailyScheduleDescription || '')}</textarea>
                            </div>

                            <div class="agent-param-grid">
                                <div class="agent-param-section">
                                    <h3>Agent Timezone</h3>
                                    <select id="agent-timezone-select" class="agent-param-input" onchange="updateAgentTimezone('${escJsAttr(agentName)}', this.value)">
                                        <option value="">Server Default</option>
                                        ${availableTimezones.map(tz => {
                                            return `<option value="${escapeHtml(tz.value)}" ${tz.value === currentTimezone ? 'selected' : ''}>${escapeHtml(tz.label)}</option>`;
                                        }).join('')}
                                    </select>
                                </div>
                                <div class="agent-param-section">
                                    <h3>Context Reset</h3>
                                    <label class="agent-param-checkbox-label" style="margin-top: 8px;">
                                        <input type="checkbox" id="reset-context-toggle" ${resetContextOnFirstMessage ? 'checked' : ''} ${!isDisabled ? 'disabled' : ''} 
                                            onchange="updateAgentResetContext('${escJsAttr(agentName)}', this.checked)">
                                        Reset Context On First Message
                                    </label>
                                </div>
                            </div>

                            <div class="agent-param-grid">
                                <div class="agent-param-section">
                                    <h3>Start Typing Delay Override</h3>
                                    <input id="start-typing-delay-input" type="number" step="0.1" min="1" max="3600" class="agent-param-input" 
                                        value="${startTypingDelay !== null ? escapeHtml(String(startTypingDelay)) : ''}" 
                                        placeholder="Use global default"
                                        onchange="updateAgentStartTypingDelay('${escJsAttr(agentName)}', this.value)">
                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">Seconds (leave empty for global default, range: 1-3600)</div>
                                </div>
                                <div class="agent-param-section">
                                    <h3>Typing Speed Override</h3>
                                    <input id="typing-speed-input" type="number" step="0.1" min="1" max="1000" class="agent-param-input" 
                                        value="${typingSpeed !== null ? escapeHtml(String(typingSpeed)) : ''}" 
                                        placeholder="Use global default"
                                        onchange="updateAgentTypingSpeed('${escJsAttr(agentName)}', this.value)">
                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">Characters per second (leave empty for global default, range: 1-1000)</div>
                                </div>
                            </div>
                            
                            <div class="agent-param-section">
                                <h3>Agent Instructions</h3>
                                <textarea 
                                    id="agent-prompt-textarea" 
                                    class="agent-param-textarea" style="min-height: 300px;"
                                    oninput="scheduleAgentPromptAutoSave('${escJsAttr(agentName)}')"
                                >${escapeHtml(prompt)}</textarea>
                                <div id="agent-prompt-status" style="margin-top: 8px; font-size: 12px; color: #28a745;">Saved</div>
                            </div>
                        </div>
                    `;
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    container.innerHTML = `<div class="error">Error loading configuration: ${escapeHtml(error)}</div>`;
                });
        }

        function updateAgentPhone(agentName, phone) {
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/phone`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ phone: phone })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) alert('Error updating phone: ' + data.error);
                else alert('Phone number updated successfully');
                loadAgentConfiguration(agentName);
            })
            .catch(error => {
                if (error && error.message !== 'unauthorized') alert('Error updating phone: ' + error);
                loadAgentConfiguration(agentName);
            });
        }

        function updateAgentName(agentName, name) {
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/name`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: name })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) alert('Error updating name: ' + data.error);
                else {
                    alert('Agent name updated successfully');
                    loadAgents().then(() => {
                        document.getElementById('agents-agent-select').value = agentName;
                    });
                    loadAgentConfiguration(agentName);
                }
            })
            .catch(error => {
                if (error && error.message !== 'unauthorized') alert('Error updating name: ' + error);
                loadAgentConfiguration(agentName);
            });
        }

        function addRolePrompt(agentName, roleName) {
            // Get current prompts and add new one
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration`)
                .then(r => r.json())
                .then(data => {
                    const prompts = data.role_prompt_names || [];
                    if (!prompts.includes(roleName)) {
                        prompts.push(roleName);
                        saveRolePrompts(agentName, prompts);
                    }
                });
        }

        function removeRolePrompt(agentName, roleName) {
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration`)
                .then(r => r.json())
                .then(data => {
                    const prompts = (data.role_prompt_names || []).filter(p => p !== roleName);
                    saveRolePrompts(agentName, prompts);
                });
        }

        function saveRolePrompts(agentName, prompts) {
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/role-prompts`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ role_prompt_names: prompts })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) alert('Error updating role prompts: ' + data.error);
                loadAgentConfiguration(agentName);
            })
            .catch(error => {
                if (error && error.message !== 'unauthorized') alert('Error updating role prompts: ' + error);
                loadAgentConfiguration(agentName);
            });
        }

        function updateAgentStickers(agentName) {
            const sets = document.getElementById('agent-sticker-sets-textarea').value.split('\n').map(s => s.trim()).filter(s => s);
            const explicit = document.getElementById('agent-explicit-stickers-textarea').value.split('\n').map(s => s.trim()).filter(s => s);
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/stickers`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sticker_set_names: sets, explicit_stickers: explicit })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) alert('Error updating stickers: ' + data.error);
                loadAgentConfiguration(agentName);
            })
            .catch(error => {
                if (error && error.message !== 'unauthorized') alert('Error updating stickers: ' + error);
                loadAgentConfiguration(agentName);
            });
        }

        function updateAgentDailySchedule(agentName) {
            const enabled = document.getElementById('daily-schedule-enabled').checked;
            const description = document.getElementById('daily-schedule-textarea').value.trim();
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/daily-schedule`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled, description: description })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) alert('Error updating daily schedule: ' + data.error);
                loadAgentConfiguration(agentName);
            })
            .catch(error => {
                if (error && error.message !== 'unauthorized') alert('Error updating daily schedule: ' + error);
                loadAgentConfiguration(agentName);
            });
        }

        function updateAgentResetContext(agentName, enabled) {
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/reset-context`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ reset_context_on_first_message: enabled })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) alert('Error updating reset context: ' + data.error);
                loadAgentConfiguration(agentName);
            })
            .catch(error => {
                if (error && error.message !== 'unauthorized') alert('Error updating reset context: ' + error);
                loadAgentConfiguration(agentName);
            });
        }

        function updateAgentLLM(agentName, llmName) {
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/llm`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ llm_name: llmName })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error updating LLM: ' + data.error);
                    // Reload to restore previous value
                    loadAgentConfiguration(agentName);
                } else {
                    alert('LLM updated successfully');
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error updating LLM: ' + error);
                loadAgentConfiguration(agentName);
            });
        }

        function updateAgentTimezone(agentName, timezone) {
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/timezone`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ timezone: timezone })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error updating timezone: ' + data.error);
                    // Reload to restore previous value
                    loadAgentConfiguration(agentName);
                } else {
                    alert('Timezone updated successfully');
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error updating timezone: ' + error);
                loadAgentConfiguration(agentName);
            });
        }

        function updateAgentStartTypingDelay(agentName, value) {
            const startTypingDelay = value.trim() === '' ? '' : value.trim();
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/start-typing-delay`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ start_typing_delay: startTypingDelay })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error updating start typing delay: ' + data.error);
                    // Reload to restore previous value
                    loadAgentConfiguration(agentName);
                } else {
                    alert('Start typing delay updated successfully');
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error updating start typing delay: ' + error);
                loadAgentConfiguration(agentName);
            });
        }

        function updateAgentTypingSpeed(agentName, value) {
            const typingSpeed = value.trim() === '' ? '' : value.trim();
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/typing-speed`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ typing_speed: typingSpeed })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error updating typing speed: ' + data.error);
                    // Reload to restore previous value
                    loadAgentConfiguration(agentName);
                } else {
                    alert('Typing speed updated successfully');
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error updating typing speed: ' + error);
                loadAgentConfiguration(agentName);
            });
        }

        // Auto-save for agent prompt
        let agentPromptAutoSaveTimer = null;
        function scheduleAgentPromptAutoSave(agentName) {
            if (agentPromptAutoSaveTimer) {
                clearTimeout(agentPromptAutoSaveTimer);
            }
            
            const statusEl = document.getElementById('agent-prompt-status');
            if (statusEl) {
                statusEl.textContent = 'Typing...';
                statusEl.style.color = '#007bff';
            }
            
            agentPromptAutoSaveTimer = setTimeout(() => {
                const textarea = document.getElementById('agent-prompt-textarea');
                const prompt = textarea.value.trim();
                
                if (statusEl) {
                    statusEl.textContent = 'Saving...';
                    statusEl.style.color = '#007bff';
                }
                
                fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/configuration/prompt`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ prompt: prompt })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        if (statusEl) {
                            statusEl.textContent = 'Error';
                            statusEl.style.color = '#dc3545';
                        }
                    } else {
                        if (statusEl) {
                            statusEl.textContent = 'Saved';
                            statusEl.style.color = '#28a745';
                        }
                    }
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    if (statusEl) {
                        statusEl.textContent = 'Error';
                        statusEl.style.color = '#dc3545';
                    }
                });
            }, 1000);
        }

        // Load recent conversations dropdown
        async function loadRecentConversations() {
            try {
                const response = await fetchWithAuth(`${API_BASE}/agents/recent-conversations`);
                const data = await response.json();
                if (data.error) {
                    console.error('Error loading recent conversations:', data.error);
                    return;
                }
                
                const conversations = data.conversations || [];
                const select = document.getElementById('recent-conversations-select');
                if (!select) {
                    return;
                }
                
                // Clear existing options except the first one
                select.innerHTML = '<option value="">Select a recent conversation...</option>';
                
                conversations.forEach(conv => {
                    const option = document.createElement('option');
                    // Format: "Agent Name / Channel Name (date)"
                    const date = conv.last_send_time ? new Date(conv.last_send_time).toLocaleDateString() : '';
                    const displayText = date 
                        ? `${conv.agent_name} / ${conv.channel_name} (${date})`
                        : `${conv.agent_name} / ${conv.channel_name}`;
                    option.textContent = displayText;
                    // Store data in value as JSON
                    option.value = JSON.stringify({
                        agent_config_name: conv.agent_config_name,
                        channel_id: conv.channel_id
                    });
                    select.appendChild(option);
                });
            } catch (error) {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                console.error('Error loading recent conversations:', error);
            }
        }
        
        // Load conversation partners
        async function loadConversationPartners(agentName, subtab, forceRefresh = false) {
            try {
                const refreshParam = forceRefresh ? '?refresh=true' : '';
                const response = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation-partners${refreshParam}`);
                const data = await response.json();
                if (data.error) {
                    console.error('Error loading conversation partners:', data.error);
                    return;
                }
                
                const partners = data.partners || [];
                const select = document.getElementById('conversations-partner-select');
                if (select) {
                    const currentValue = select.value;
                    const subtabName = getCurrentConversationsSubtab();
                    
                    // Check content for each partner using batch endpoint
                    const partnerContentChecks = {};
                    const userIds = partners.map(p => p.user_id || p);
                    
                    // Map subtab names to content check keys
                    const subtabToKey = {
                        'notes-conv': 'notes',
                        'conversation-llm': 'conversation_llm',
                        'plans': 'plans',
                        'conversation': 'conversation'  // Special case, uses different endpoint
                    };
                    
                    if (subtabName === 'conversation') {
                        // For conversation subtab, use conversation-content-check endpoint
                        try {
                            const batchResponse = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation-content-check`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({ user_ids: userIds })
                            });
                            const batchData = await batchResponse.json();
                            if (batchData.content_checks) {
                                Object.assign(partnerContentChecks, batchData.content_checks);
                            }
                        } catch (error) {
                            console.warn('Error checking conversation content batch:', error);
                            // Fall back to individual checks if batch fails
                            await Promise.all(partners.map(async (partner) => {
                                const userId = partner.user_id || partner;
                                partnerContentChecks[userId] = await partnerHasContent(agentName, userId, subtabName);
                            }));
                        }
                    } else {
                        // For notes, conversation-llm, and plans, use partner-content-check endpoint
                        try {
                            const batchResponse = await fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/partner-content-check`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({ user_ids: userIds })
                            });
                            const batchData = await batchResponse.json();
                            if (batchData.content_checks) {
                                // Map the batch response to the format expected by the frontend
                                const contentKey = subtabToKey[subtabName];
                                if (contentKey) {
                                    for (const userId of userIds) {
                                        const checks = batchData.content_checks[userId];
                                        if (checks) {
                                            partnerContentChecks[userId] = checks[contentKey] || false;
                                        } else {
                                            partnerContentChecks[userId] = false;
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            console.warn('Error checking partner content batch:', error);
                            // Fall back to individual checks if batch fails
                            await Promise.all(partners.map(async (partner) => {
                                const userId = partner.user_id || partner;
                                partnerContentChecks[userId] = await partnerHasContent(agentName, userId, subtabName);
                            }));
                        }
                    }
                    
                    select.innerHTML = '<option value="">Choose a partner...</option>';
                    partners.forEach(partner => {
                        const option = document.createElement('option');
                        const userId = partner.user_id || partner;
                        option.value = userId;
                        // Display format: "Name (user_id) [@username]" or "Name (user_id)" or just "user_id"
                        // Check for both null/undefined and empty string
                        const hasName = partner.name && partner.name.trim().length > 0;
                        let displayName = hasName ? `${partner.name} (${userId})` : userId;
                        
                        // Add Telegram username if available
                        if (partner.username) {
                            displayName += ` [@${partner.username}]`;
                        }
                        
                        // Add asterisk if partner has content for current subtab
                        if (partnerContentChecks[userId]) {
                            displayName += ' *';
                        }
                        option.textContent = displayName;
                        select.appendChild(option);
                    });
                    // When setting value, strip asterisk if present for comparison
                    if (currentValue) {
                        const strippedValue = stripAsterisk(currentValue);
                        select.value = strippedValue;
                    }
                }
            } catch (error) {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                console.error('Error loading conversation partners:', error);
            }
        }

        // Functions for Parameters subtabs
        function loadNotesForPartner() {
            const agentSelect = document.getElementById('conversations-agent-select');
            const partnerSelect = document.getElementById('conversations-partner-select');
            const userIdInput = document.getElementById('conversations-user-id');
            
            const agentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
            const userId = userIdInput?.value.trim() || (partnerSelect ? stripAsterisk(partnerSelect.value) : '');
            
            if (!agentName || !userId) {
                alert('Please select an agent and enter/select a conversation partner');
                return;
            }
            
            const container = document.getElementById('notes-conv-container');
            container.innerHTML = '<div class="loading">Loading notes...</div>';
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/notes/${userId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        container.innerHTML = `<div class="error">Error: ${escapeHtml(data.error)}</div>`;
                        return;
                    }
                    
                    const notes = data.notes || [];
                    let html = '<div style="margin-bottom: 16px;"><button onclick="createNewNoteForPartner(\'' + escJsAttr(agentName) + '\', \'' + escJsAttr(userId) + '\')" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">+ Add New Note</button></div>';
                    
                    if (notes.length === 0) {
                        html += '<div class="placeholder-card">No notes found for this user.</div>';
                        container.innerHTML = html;
                        return;
                    }
                    
                    html += notes.map(note => `
                        <div class="memory-item" style="background: white; padding: 16px; margin-bottom: 16px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                                <div>
                                    <strong>ID:</strong> ${escapeHtml(note.id || 'N/A')}<br>
                                    <strong>Created:</strong> ${escapeHtml(note.created || 'N/A')}
                                </div>
                                <button onclick="deleteNote('${escJsAttr(agentName)}', '${escJsAttr(userId)}', '${escJsAttr(note.id)}')" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Delete</button>
                            </div>
                            <textarea 
                                id="note-params-${userId}-${note.id}" 
                                style="width: 100%; min-height: 100px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; resize: vertical; box-sizing: border-box;"
                                oninput="scheduleNoteAutoSave('${escJsAttr(agentName)}', '${escJsAttr(userId)}', '${escJsAttr(note.id)}')"
                            >${escapeHtml(note.content || '')}</textarea>
                            <div id="note-status-${userId}-${note.id}" style="margin-top: 8px; font-size: 12px; color: #28a745;">Saved</div>
                        </div>
                    `).join('');
                    container.innerHTML = html;
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    container.innerHTML = `<div class="error">Error loading notes: ${escapeHtml(error)}</div>`;
                });
        }

        function createNewNoteForPartner(agentName, userId) {
            if (!agentName || !userId) {
                alert('Please select an agent and conversation partner');
                return;
            }
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/notes/${userId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ content: 'New note entry' })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error creating note: ' + data.error);
                } else {
                    loadNotesForPartner();
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error creating note: ' + error);
            });
        }

        function loadConversationLLM() {
            const agentSelect = document.getElementById('conversations-agent-select');
            const partnerSelect = document.getElementById('conversations-partner-select');
            const userIdInput = document.getElementById('conversations-user-id');
            
            const agentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
            const userId = userIdInput?.value.trim() || (partnerSelect ? stripAsterisk(partnerSelect.value) : '');
            
            if (!agentName || !userId) {
                alert('Please select an agent and enter/select a conversation partner');
                return;
            }
            
            const container = document.getElementById('conversation-llm-container');
            container.innerHTML = '<div class="loading">Loading conversation LLM...</div>';
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation-llm/${userId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        container.innerHTML = `<div class="error">Error: ${escapeHtml(data.error)}</div>`;
                        return;
                    }
                    
                    const conversationLLM = data.conversation_llm || null;
                    const agentDefaultLLM = data.agent_default_llm || '';
                    const availableLLMs = data.available_llms || [];
                    
                    container.innerHTML = `
                        <div style="background: white; padding: 16px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <h3>Conversation LLM</h3>
                            <p>Current: ${escapeHtml(conversationLLM || agentDefaultLLM + ' (agent default)')}</p>
                            <select id="conversation-llm-select" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; min-width: 300px; margin-bottom: 16px;" onchange="updateConversationLLM('${escJsAttr(agentName)}', '${escJsAttr(userId)}', this.value)">
                                ${availableLLMs.map(llm => {
                                    const isSelected = (conversationLLM === llm.value || (!conversationLLM && llm.value === agentDefaultLLM));
                                    return `<option value="${escapeHtml(llm.value)}" ${isSelected ? 'selected' : ''}>${escapeHtml(llm.label)}${llm.is_default ? ' *' : ''}</option>`;
                                }).join('')}
                            </select>
                        </div>
                    `;
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    container.innerHTML = `<div class="error">Error loading conversation LLM: ${escapeHtml(error)}</div>`;
                });
        }

        function updateConversationLLM(agentName, userId, llmName) {
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation-llm/${userId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ llm_name: llmName })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error updating conversation LLM: ' + data.error);
                } else {
                    // Reload to show updated value
                    loadConversationLLM();
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error updating conversation LLM: ' + error);
            });
        }

        function loadPlans() {
            const agentSelect = document.getElementById('conversations-agent-select');
            const partnerSelect = document.getElementById('conversations-partner-select');
            const userIdInput = document.getElementById('conversations-user-id');
            
            const agentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
            const userId = userIdInput?.value.trim() || (partnerSelect ? stripAsterisk(partnerSelect.value) : '');
            
            if (!agentName || !userId) {
                alert('Please select an agent and enter/select a conversation partner');
                return;
            }
            
            const container = document.getElementById('plans-container');
            container.innerHTML = '<div class="loading">Loading plans...</div>';
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/plans/${userId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        container.innerHTML = `<div class="error">Error: ${escapeHtml(data.error)}</div>`;
                        return;
                    }
                    
                    const plans = data.plans || [];
                    let html = '<div style="margin-bottom: 16px;"><button onclick="createNewPlan(\'' + escJsAttr(agentName) + '\', \'' + escJsAttr(userId) + '\')" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">+ Add New Plan</button></div>';
                    
                    if (plans.length === 0) {
                        html += '<div class="placeholder-card">No plans found for this conversation.</div>';
                        container.innerHTML = html;
                        return;
                    }
                    
                    html += plans.map(plan => `
                        <div class="memory-item" style="background: white; padding: 16px; margin-bottom: 16px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                                <div>
                                    <strong>ID:</strong> ${escapeHtml(plan.id || 'N/A')}<br>
                                    <strong>Created:</strong> ${escapeHtml(plan.created || 'N/A')}
                                </div>
                                <button onclick="deletePlan('${escJsAttr(agentName)}', '${escJsAttr(userId)}', '${escJsAttr(plan.id)}')" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Delete</button>
                            </div>
                            <textarea 
                                id="plan-${userId}-${plan.id}" 
                                style="width: 100%; min-height: 100px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; resize: vertical; box-sizing: border-box;"
                                oninput="schedulePlanAutoSave('${escJsAttr(agentName)}', '${escJsAttr(userId)}', '${escJsAttr(plan.id)}')"
                            >${escapeHtml(plan.content || '')}</textarea>
                            <div id="plan-status-${userId}-${plan.id}" style="margin-top: 8px; font-size: 12px; color: #28a745;">Saved</div>
                        </div>
                    `).join('');
                    container.innerHTML = html;
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    container.innerHTML = `<div class="error">Error loading plans: ${escapeHtml(error)}</div>`;
                });
        }

        function createNewPlan(agentName, userId) {
            if (!agentName || !userId) {
                alert('Please select an agent and conversation partner');
                return;
            }
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/plans/${userId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ content: 'New plan entry' })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error creating plan: ' + data.error);
                } else {
                    loadPlans();
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error creating plan: ' + error);
            });
        }

        // Auto-save for plans
        const planAutoSaveTimers = {};
        function schedulePlanAutoSave(agentName, userId, planId) {
            const key = `${userId}-${planId}`;
            if (planAutoSaveTimers[key]) {
                clearTimeout(planAutoSaveTimers[key]);
            }
            
            const statusEl = document.getElementById(`plan-status-${userId}-${planId}`);
            if (statusEl) {
                statusEl.textContent = 'Typing...';
                statusEl.style.color = '#007bff';
            }
            
            planAutoSaveTimers[key] = setTimeout(() => {
                const textarea = document.getElementById(`plan-${userId}-${planId}`);
                if (!textarea) {
                    return; // Element no longer exists
                }
                const content = textarea.value.trim();
                
                const statusEl = document.getElementById(`plan-status-${userId}-${planId}`);
                if (statusEl) {
                    statusEl.textContent = 'Saving...';
                    statusEl.style.color = '#007bff';
                }
                
                fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/plans/${userId}/${planId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ content: content })
                })
                .then(response => response.json())
                .then(data => {
                    const statusEl = document.getElementById(`plan-status-${userId}-${planId}`);
                    if (statusEl) {
                        if (data.error) {
                            statusEl.textContent = 'Error';
                            statusEl.style.color = '#dc3545';
                        } else {
                            statusEl.textContent = 'Saved';
                            statusEl.style.color = '#28a745';
                        }
                    }
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    const statusEl = document.getElementById(`plan-status-${userId}-${planId}`);
                    if (statusEl) {
                        statusEl.textContent = 'Error';
                        statusEl.style.color = '#dc3545';
                    }
                });
            }, 1000);
        }

        function deletePlan(agentName, userId, planId) {
            if (!confirm('Are you sure you want to delete this plan?')) {
                return;
            }
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/plans/${userId}/${planId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error deleting plan: ' + data.error);
                } else {
                    loadPlans();
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error deleting plan: ' + error);
            });
        }

        // Auto-save for summaries
        const summaryAutoSaveTimers = {};
        function scheduleSummaryAutoSave(agentName, userId, summaryId) {
            const key = `${userId}-${summaryId}`;
            if (summaryAutoSaveTimers[key]) {
                clearTimeout(summaryAutoSaveTimers[key]);
            }
            
            const statusEl = document.getElementById(`summary-status-${userId}-${summaryId}`);
            if (statusEl) {
                statusEl.textContent = 'Typing...';
                statusEl.style.color = '#007bff';
            }
            
            summaryAutoSaveTimers[key] = setTimeout(() => {
                const textarea = document.getElementById(`summary-${userId}-${summaryId}`);
                const minInput = document.getElementById(`summary-min-${userId}-${summaryId}`);
                const maxInput = document.getElementById(`summary-max-${userId}-${summaryId}`);
                const firstDateInput = document.getElementById(`summary-first-date-${userId}-${summaryId}`);
                const lastDateInput = document.getElementById(`summary-last-date-${userId}-${summaryId}`);
                
                if (!textarea || !minInput || !maxInput) {
                    return; // Elements no longer exist
                }
                
                const content = textarea.value.trim();
                const minMessageId = parseInt(minInput.value) || null;
                const maxMessageId = parseInt(maxInput.value) || null;
                const firstMessageDate = firstDateInput ? firstDateInput.value.trim() || null : null;
                const lastMessageDate = lastDateInput ? lastDateInput.value.trim() || null : null;
                
                const statusEl = document.getElementById(`summary-status-${userId}-${summaryId}`);
                if (statusEl) {
                    statusEl.textContent = 'Saving...';
                    statusEl.style.color = '#007bff';
                }
                
                fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/summaries/${userId}/${summaryId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        content: content,
                        min_message_id: minMessageId,
                        max_message_id: maxMessageId,
                        first_message_date: firstMessageDate,
                        last_message_date: lastMessageDate
                    })
                })
                .then(response => response.json())
                .then(data => {
                    const statusEl = document.getElementById(`summary-status-${userId}-${summaryId}`);
                    if (statusEl) {
                        if (data.error) {
                            statusEl.textContent = 'Error';
                            statusEl.style.color = '#dc3545';
                        } else {
                            statusEl.textContent = 'Saved';
                            statusEl.style.color = '#28a745';
                        }
                    }
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    const statusEl = document.getElementById(`summary-status-${userId}-${summaryId}`);
                    if (statusEl) {
                        statusEl.textContent = 'Error';
                        statusEl.style.color = '#dc3545';
                    }
                });
            }, 1000);
        }

        function deleteSummary(agentName, userId, summaryId, reloadConversation = true) {
            if (!confirm('Are you sure you want to delete this summary?')) {
                return;
            }
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/summaries/${userId}/${summaryId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error deleting summary: ' + data.error);
                } else {
                    // Always reload conversation since Summaries subtab is removed
                    loadConversation();
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                alert('Error deleting summary: ' + error);
            });
        }

        let conversationMessages = [];
        let conversationTranslations = {};
        let showTranslation = false;
        let conversationAgentTimezone = null;

        function loadConversation() {
            const agentSelect = document.getElementById('conversations-agent-select');
            const partnerSelect = document.getElementById('conversations-partner-select');
            const userIdInput = document.getElementById('conversations-user-id');
            
            const agentName = agentSelect ? stripAsterisk(agentSelect.value) : null;
            const userId = userIdInput?.value.trim() || (partnerSelect ? stripAsterisk(partnerSelect.value) : '');
            
            if (!agentName || !userId) {
                alert('Please select an agent and enter/select a conversation partner');
                return;
            }
            
            const container = document.getElementById('conversation-container');
            container.innerHTML = '<div class="loading">Loading conversation...</div>';
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation/${userId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        container.innerHTML = `<div class="error">Error: ${escapeHtml(data.error)}</div>`;
                        return;
                    }
                    
                    const summaries = data.summaries || [];
                    const messages = data.messages || [];
                    const agentTimezone = data.agent_timezone;
                    const isBlocked = data.is_blocked || false;
                    conversationMessages = messages;
                    conversationTranslations = {};
                    conversationAgentTimezone = agentTimezone;
                    // Preserve showTranslation state instead of resetting it
                    // showTranslation state is preserved
                    
                    renderConversation(agentName, userId, summaries, messages, agentTimezone, isBlocked);
                    
                    // Restore checkbox state after rendering if it was checked
                    const checkbox = document.getElementById('translation-toggle');
                    if (checkbox) {
                        checkbox.checked = showTranslation;
                    }
                    
                    // If translations were enabled, trigger the translation stream to fetch them
                    // Only start if checkbox exists (i.e., there are unsummarized messages)
                    if (showTranslation && checkbox) {
                        startTranslationStream(agentName, userId, checkbox);
                    }
                })
                .catch(error => {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    container.innerHTML = `<div class="error">Error loading conversation: ${escapeHtml(error)}</div>`;
                });
        }

        function renderConversation(agentName, userId, summaries, messages, agentTimezone, isBlocked = false) {
            const container = document.getElementById('conversation-container');
            let html = '';
            
            // Display blocked status banner at the top if conversation is blocked
            if (isBlocked) {
                html += '<div style="background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 12px; margin-bottom: 16px; display: flex; align-items: center; gap: 8px;">';
                html += '<span style="font-size: 18px;">⚠️</span>';
                html += '<div><strong>This conversation is blocked.</strong> The agent cannot send messages to this conversation.</div>';
                html += '</div>';
            }
            
            // Helper function to convert UTC timestamp to agent timezone for display
            // Matches the format used in prompts: "YYYY-MM-DD HH:MM:SS TZ"
            function formatTimestamp(utcTimestamp) {
                if (!utcTimestamp) return 'N/A';
                try {
                    const date = new Date(utcTimestamp);
                    // Use agentTimezone if provided (backend sends fallback to server timezone)
                    // Format: YYYY-MM-DD HH:MM:SS TZ (matching prompt format)
                    const tz = agentTimezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
                    const formatted = date.toLocaleString('en-US', {
                        timeZone: tz,
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false,
                        timeZoneName: 'short'
                    });
                    // Convert from "MM/DD/YYYY, HH:MM:SS TZ" to "YYYY-MM-DD HH:MM:SS TZ"
                    const parts = formatted.match(/(\d{2})\/(\d{2})\/(\d{4}),?\s+(\d{2}:\d{2}:\d{2})\s+(.+)/);
                    if (parts) {
                        return `${parts[3]}-${parts[1]}-${parts[2]} ${parts[4]} ${parts[5]}`;
                    }
                    return formatted;
                } catch (e) {
                    return utcTimestamp;
                }
            }
            
            // Display summaries at the top (editable, styled like memories)
            if (summaries.length > 0) {
                html += '<div style="margin-bottom: 24px;"><h3 style="margin-bottom: 12px; font-size: 18px; font-weight: bold;">Conversation Summaries</h3>';
                html += summaries.map(summary => `
                    <div class="memory-item" style="background: white; padding: 16px; margin-bottom: 16px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                            <div>
                                <strong>ID:</strong> ${escapeHtml(summary.id || 'N/A')}<br>
                                <strong>Created:</strong> ${escapeHtml(summary.created || 'N/A')}
                            </div>
                            <button onclick="deleteSummary('${escJsAttr(agentName)}', '${escJsAttr(userId)}', '${escJsAttr(summary.id)}', true)" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Delete</button>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <span style="font-weight: bold; font-size: 12px; white-space: nowrap;">Message IDs:</span>
                                <input type="number" id="summary-min-${userId}-${summary.id}" value="${escapeHtml(String(summary.min_message_id || ''))}" 
                                    oninput="scheduleSummaryAutoSave('${escJsAttr(agentName)}', '${escJsAttr(userId)}', '${escJsAttr(summary.id)}')"
                                    style="width: 100px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; font-size: 12px;">
                                <span style="color: #666; font-size: 12px;">-</span>
                                <input type="number" id="summary-max-${userId}-${summary.id}" value="${escapeHtml(String(summary.max_message_id || ''))}" 
                                    oninput="scheduleSummaryAutoSave('${escJsAttr(agentName)}', '${escJsAttr(userId)}', '${escJsAttr(summary.id)}')"
                                    style="width: 100px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; font-size: 12px;">
                            </div>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <span style="font-weight: bold; font-size: 12px; white-space: nowrap;">Dates:</span>
                                <input type="date" id="summary-first-date-${userId}-${summary.id}" value="${summary.first_message_date ? escapeHtml(summary.first_message_date) : ''}" 
                                    oninput="scheduleSummaryAutoSave('${escJsAttr(agentName)}', '${escJsAttr(userId)}', '${escJsAttr(summary.id)}')"
                                    style="width: 150px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; font-size: 12px;">
                                <span style="color: #666; font-size: 12px;">to</span>
                                <input type="date" id="summary-last-date-${userId}-${summary.id}" value="${summary.last_message_date ? escapeHtml(summary.last_message_date) : ''}" 
                                    oninput="scheduleSummaryAutoSave('${escJsAttr(agentName)}', '${escJsAttr(userId)}', '${escJsAttr(summary.id)}')"
                                    style="width: 150px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; font-size: 12px;">
                            </div>
                        </div>
                        <textarea 
                            id="summary-${userId}-${summary.id}" 
                            style="width: 100%; min-height: 100px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; resize: vertical; box-sizing: border-box;"
                            oninput="scheduleSummaryAutoSave('${escJsAttr(agentName)}', '${escJsAttr(userId)}', '${escJsAttr(summary.id)}')"
                        >${escapeHtml(summary.content || '')}</textarea>
                        <div id="summary-status-${userId}-${summary.id}" style="margin-top: 8px; font-size: 12px; color: #28a745;">Saved</div>
                    </div>
                `).join('');
                html += '</div>';
            }
            
            // Display unsummarized messages
            if (messages.length === 0 && summaries.length === 0) {
                html += '<div class="placeholder-card">No conversation history found.</div>';
            } else {
                // Show "Delete Telepathic Messages" button whenever there's conversation history
                if (messages.length === 0) {
                    // All messages summarized - show placeholder and delete button
                    html += '<div class="placeholder-card" style="margin-top: 16px;">All messages have been summarized. Only unsummarized messages are shown here.</div>';
                    html += '<div style="display: flex; justify-content: flex-end; align-items: center; margin-top: 12px; margin-bottom: 12px;">';
                    html += `<button id="delete-telepathic-btn-${userId}" onclick="deleteTelepathicMessages('${escJsAttr(agentName)}', '${escJsAttr(userId)}', this)" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Delete Telepathic Messages</button>`;
                    html += '</div>';
                } else {
                    // Has unsummarized messages - show header with all controls
                    html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">';
                    html += '<h3 style="margin: 0; font-size: 18px; font-weight: bold;">Unsummarized Messages</h3>';
                    html += '<div style="display: flex; align-items: center; gap: 16px;">';
                    html += '<label style="display: flex; align-items: center; cursor: pointer; font-size: 14px;">';
                    html += `<input type="checkbox" id="translation-toggle" ${showTranslation ? 'checked' : ''} onchange="toggleTranslation('${escJsAttr(agentName)}', '${escJsAttr(userId)}')" style="margin-right: 8px;">`;
                    html += 'Display Translation</label>';
                    html += `<button id="delete-telepathic-btn-${userId}" onclick="deleteTelepathicMessages('${escJsAttr(agentName)}', '${escJsAttr(userId)}', this)" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Delete Telepathic Messages</button>`;
                    html += `<button id="summarize-btn-${userId}" onclick="triggerSummarization('${escJsAttr(agentName)}', '${escJsAttr(userId)}', this)" style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Summarize Conversation</button>`;
                    html += `<button id="download-btn-${userId}" onclick="downloadConversation('${escJsAttr(agentName)}', '${escJsAttr(userId)}', this)" style="padding: 6px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">Download Conversation</button>`;
                    html += '</div>';
                    html += '</div>';
                }
                
                html += messages.map(msg => {
                    // Build content from parts if available (includes media/stickers)
                    let contentHtml = '';
                    let hasTextContent = false;
                    
                    if (msg.parts && Array.isArray(msg.parts) && msg.parts.length > 0) {
                        // Use parts to show rich content
                        msg.parts.forEach(part => {
                            if (part.kind === 'text' && part.text) {
                                hasTextContent = true;
                                // Text is already HTML (from backend)
                                const partText = showTranslation && conversationTranslations[msg.id] 
                                    ? conversationTranslations[msg.id] 
                                    : part.text;
                                // Use CSS to ensure emojis render consistently (don't apply font-weight/font-style to emojis)
                                contentHtml += `<div style="white-space: pre-wrap; margin-bottom: 4px;">${partText}</div>`;
                            } else if (part.kind === 'media') {
                                const mediaKind = part.media_kind || 'media';
                                const uniqueId = part.unique_id;
                                const messageId = part.message_id || msg.id;
                                const mediaUrl = `${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation/${userId}/media/${messageId}/${uniqueId}`;
                                
                                // Render actual media based on type
                                // Check if sticker is animated (either via media_kind or is_animated flag)
                                const isAnimatedSticker = mediaKind === 'animated_sticker' || (mediaKind === 'sticker' && part.is_animated);
                                
                                if (mediaKind === 'photo' || (mediaKind === 'sticker' && !isAnimatedSticker)) {
                                    // Static images and regular stickers
                                    contentHtml += `<div style="margin-bottom: 4px;"><img src="${mediaUrl}" alt="${part.sticker_name || uniqueId}" style="max-width: 300px; max-height: 300px; border-radius: 8px;"></div>`;
                                } else if (isAnimatedSticker) {
                                    // Animated stickers (TGS) - use Lottie player like in media editor
                                    contentHtml += `<div style="margin-bottom: 4px; position: relative; width: 200px; height: 200px; display: flex; align-items: center; justify-content: center;">
                                        <div id="tgs-player-${uniqueId}" class="tgs-animation-container" data-message-id="${messageId}" data-unique-id="${uniqueId}" style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">
                                            <div style="text-align: center; color: #666;">
                                                <div style="font-size: 24px; margin-bottom: 10px;">🎭</div>
                                                <div style="font-size: 12px; margin-bottom: 10px;">Loading TGS animation...</div>
                                                <a href="${mediaUrl}" download style="color: #007bff; text-decoration: none; font-size: 11px;">Download TGS</a>
                                            </div>
                                        </div>
                                    </div>`;
                                } else if (mediaKind === 'video' || mediaKind === 'animation' || mediaKind === 'gif') {
                                    // Videos, animations, and GIFs
                                    contentHtml += `<div style="margin-bottom: 4px;"><video controls autoplay loop muted style="max-width: 300px; max-height: 300px; border-radius: 8px;"><source src="${mediaUrl}"></video></div>`;
                                } else if (mediaKind === 'audio') {
                                    contentHtml += `<div style="margin-bottom: 4px;"><audio controls style="width: 100%; max-width: 400px;"><source src="${mediaUrl}"></audio></div>`;
                                } else {
                                    // Fallback: show description with download link
                                    const renderedText = part.rendered_text || '';
                                    const stickerInfo = part.sticker_set_name 
                                        ? ` (${part.sticker_set_name}${part.sticker_name ? ` / ${part.sticker_name}` : ''})`
                                        : '';
                                    contentHtml += `<div style="color: #666; font-style: italic; margin-bottom: 4px;">${renderedText.replace(/</g, '&lt;').replace(/>/g, '&gt;')}${stickerInfo} <a href="${mediaUrl}" download style="color: #007bff; text-decoration: none;">[Download]</a></div>`;
                                }
                                
                                // Add description text if available (below the media)
                                if (part.rendered_text) {
                                    contentHtml += `<div style="color: #666; font-size: 11px; margin-top: 2px; margin-bottom: 4px; font-style: italic;">${part.rendered_text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>`;
                                }
                            }
                        });
                    }
                    
                    // Fallback to text if no parts or if parts didn't include text
                    if (!hasTextContent && msg.text) {
                        // Text is already HTML (from backend)
                        const displayText = showTranslation && conversationTranslations[msg.id] 
                            ? conversationTranslations[msg.id] 
                            : msg.text;
                        contentHtml = `<div style="white-space: pre-wrap;">${displayText}</div>`;
                    }
                    
                    // If still no content, show placeholder
                    if (!contentHtml) {
                        contentHtml = '<div style="color: #999; font-style: italic;">[No content]</div>';
                    }
                    
                    // Build metadata line with sender name and ID
                    let senderDisplay = '';
                    if (msg.sender_name && msg.sender_id) {
                        senderDisplay = `<strong>${escapeHtml(msg.sender_name || '')}</strong> (${escapeHtml(String(msg.sender_id))})`;
                    } else if (msg.sender_id) {
                        senderDisplay = `<strong>${msg.sender_id}</strong>`;
                    } else {
                        senderDisplay = msg.is_from_agent ? '<strong>Agent</strong>' : '<strong>User</strong>';
                    }
                    let metadataLine = `${senderDisplay} • ${formatTimestamp(msg.timestamp)} • ID: ${msg.id}`;
                    if (msg.reply_to_msg_id) {
                        metadataLine += ` • Reply to: ${msg.reply_to_msg_id}`;
                    }
                    // Add read receipt checkmark for agent messages in DMs
                    // is_read_by_partner is only set for agent messages in DMs (null/undefined otherwise)
                    if (msg.is_read_by_partner === true) {
                        metadataLine += ` ✔️`;
                    }
                    
                    // Add reactions if present
                    // Note: msg.reactions may contain HTML (img tags for custom emojis) added by the backend,
                    // so we should NOT escape it - the backend intentionally provides HTML to render
                    let reactionsHtml = '';
                    if (msg.reactions) {
                        reactionsHtml = `<div style="font-size: 11px; color: #888; margin-top: 4px; font-style: italic;">Reactions: ${msg.reactions}</div>`;
                    }
                    
                    // Determine background color: grey if translation is requested but not available, otherwise normal
                    let bgColor = msg.is_from_agent ? '#e3f2fd' : 'white';
                    if (showTranslation && msg.text && !conversationTranslations[msg.id]) {
                        bgColor = '#e0e0e0'; // Grey background for messages awaiting translation
                    }
                    
                    return `
                        <div id="message-${msg.id}" data-message-id="${msg.id}" style="background: ${bgColor}; padding: 12px; margin-bottom: 8px; border-radius: 8px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); border-left: 4px solid ${msg.is_from_agent ? '#2196f3' : '#4caf50'};">
                            <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
                                ${metadataLine}
                            </div>
                            ${contentHtml}
                            ${reactionsHtml}
                        </div>
                    `;
                }).join('');
            }
            
            // Add refresh button at the bottom
            html += '<div style="margin-top: 16px; padding: 12px; text-align: center; border-top: 1px solid #ddd;">';
            html += `<button onclick="loadConversation()" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Refresh Conversation</button>`;
            html += '</div>';
            
            container.innerHTML = html;
            
            // Load TGS animations for animated stickers in conversation (same as media editor)
            setTimeout(() => {
                loadTGSAnimationsForConversation(agentName, userId);
                loadCustomEmojiAnimations(agentName);
            }, 100);
        }
        
        async function loadCustomEmojiAnimations(agentName) {
            // Find all custom emoji images (both reactions and message text) and check if they're animated (TGS)
            // Only process images that haven't been processed yet (don't have the processed flag)
            // Query for both:
            // - .custom-emoji-reaction: used in reactions (standalone img)
            // - .custom-emoji-img: used in message text (inside .custom-emoji-container)
            // Scope to conversation container to avoid processing emojis in other parts of the page
            const conversationContainer = document.getElementById('conversation-container');
            if (!conversationContainer) {
                return;
            }
            
            const emojiImages = conversationContainer.querySelectorAll('.custom-emoji-reaction:not([data-lottie-processed]), .custom-emoji-img:not([data-lottie-processed])');
            
            // Calculate indices upfront from the original DOM state to avoid index shifts
            // when images are removed during processing. Create a map from img element to its index.
            const allEmojiImages = Array.from(conversationContainer.querySelectorAll('.custom-emoji-reaction, .custom-emoji-img'));
            const imgIndexMap = new Map();
            allEmojiImages.forEach((img, index) => {
                imgIndexMap.set(img, index);
            });
            
            for (const img of emojiImages) {
                // For .custom-emoji-img, data attributes may be on the parent container
                // For .custom-emoji-reaction, data attributes are on the img itself
                const container = img.closest('.custom-emoji-container');
                const emojiUrl = img.getAttribute('data-emoji-url') || 
                                (container ? container.getAttribute('data-emoji-url') : null) ||
                                img.getAttribute('src');
                const documentId = img.getAttribute('data-document-id') ||
                                  (container ? container.getAttribute('data-document-id') : null);
                
                if (!emojiUrl || !documentId) {
                    continue;
                }
                
                // Mark as processed immediately to avoid duplicate processing
                img.setAttribute('data-lottie-processed', 'true');
                
                try {
                    // Fetch the emoji to check if it's animated (TGS)
                    // The emojiUrl should already be a full path like /admin/api/agents/...
                    const response = await fetchWithAuth(emojiUrl);
                    const contentType = response.headers.get('content-type') || '';
                    const isAnimated = response.headers.get('x-emoji-type') === 'animated' || 
                                      contentType.includes('application/gzip') || 
                                      contentType.includes('application/x-tgsticker');
                    
                    if (isAnimated) {
                        // It's a TGS file - render with Lottie
                        const tgsData = await response.arrayBuffer();
                        // Use a unique player ID that includes the document ID and position to avoid conflicts
                        // Get the index from the pre-calculated map (before any DOM removals)
                        const imgIndex = imgIndexMap.get(img);
                        const playerId = `emoji-lottie-${documentId}-${imgIndex}`;
                        
                        // Check if img is inside a container (message text) or standalone (reaction)
                        const parent = img.parentElement;
                        const isInContainer = container && container === parent;
                        
                        // Create Lottie player wrapper
                        const wrapper = document.createElement('span');
                        wrapper.style.display = 'inline-block';
                        wrapper.style.width = '1.2em';
                        wrapper.style.height = '1.2em';
                        wrapper.style.verticalAlign = 'middle';
                        wrapper.innerHTML = `<div id="${playerId}" style="width: 1.2em; height: 1.2em;"></div>`;
                        
                        if (isInContainer) {
                            // For message text emojis: replace the entire container
                            const containerParent = container.parentElement;
                            if (containerParent) {
                                containerParent.insertBefore(wrapper, container);
                                containerParent.removeChild(container);
                            } else {
                                container.replaceWith(wrapper);
                            }
                        } else {
                            // For reaction emojis: replace just the img
                            if (parent) {
                                parent.insertBefore(wrapper, img);
                                parent.removeChild(img);
                            } else {
                                img.replaceWith(wrapper);
                            }
                        }
                        
                        // Decompress and load TGS with Lottie
                        const decompressed = pako.inflate(new Uint8Array(tgsData));
                        const jsonData = JSON.parse(new TextDecoder().decode(decompressed));
                        
                        const player = lottie.loadAnimation({
                            container: document.getElementById(playerId),
                            renderer: 'svg',
                            loop: true,
                            autoplay: true,
                            animationData: jsonData
                        });
                    }
                    // If not animated, the img tag will display normally
                } catch (error) {
                    console.warn(`Failed to load custom emoji ${documentId}:`, error);
                    // Remove the processed flag on error so it can be retried
                    img.removeAttribute('data-lottie-processed');
                }
            }
        }
        
        async function loadTGSAnimationsForConversation(agentName, userId) {
            // Find all TGS player containers in conversation view
            const tgsContainers = document.querySelectorAll('#conversation-container [id^="tgs-player-"]');
            console.log(`Found ${tgsContainers.length} TGS containers in conversation to load`);

            for (const container of tgsContainers) {
                const uniqueId = container.getAttribute('data-unique-id') || container.id.replace('tgs-player-', '');
                const messageId = container.getAttribute('data-message-id');
                
                if (!messageId) {
                    console.warn(`Could not find message ID for TGS ${uniqueId}, skipping`);
                    continue;
                }
                
                const mediaUrl = `${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation/${userId}/media/${messageId}/${uniqueId}`;
                console.log(`Loading TGS for ${uniqueId} from conversation: ${mediaUrl}`);

                try {
                    // Fetch the TGS file
                    const response = await fetchWithAuth(mediaUrl);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch TGS file: ${response.status}`);
                    }

                    const tgsData = await response.arrayBuffer();

                    // Decompress the gzipped Lottie data
                    let lottieJson;

                    // Try pako first since DecompressionStream is unreliable
                    if (typeof pako !== 'undefined') {
                        try {
                            console.log('Attempting pako decompression for conversation TGS...');
                            const decompressed = pako.inflate(new Uint8Array(tgsData), { to: 'string' });
                            lottieJson = JSON.parse(decompressed);
                            console.log('Pako decompression successful for conversation TGS');
                        } catch (pakoError) {
                            console.error('Pako decompression failed:', pakoError);
                            throw new Error('Failed to decompress TGS file with pako');
                        }
                    } else {
                        // Fallback to DecompressionStream if pako not available
                        try {
                            console.log('Attempting DecompressionStream decompression for conversation TGS...');
                            const decompressedData = await decompressGzip(tgsData);
                            const jsonText = new TextDecoder().decode(decompressedData);
                            lottieJson = JSON.parse(jsonText);
                            console.log('DecompressionStream decompression successful for conversation TGS');
                        } catch (decompError) {
                            console.error('DecompressionStream failed:', decompError.message);
                            throw new Error('Failed to decompress TGS file - no suitable decompression method available');
                        }
                    }

                    // Clear the loading content and create a new container for Lottie
                    container.innerHTML = '';
                    const animationContainer = document.createElement('div');
                    animationContainer.style.width = '100%';
                    animationContainer.style.height = '100%';
                    animationContainer.style.display = 'flex';
                    animationContainer.style.alignItems = 'center';
                    animationContainer.style.justifyContent = 'center';
                    animationContainer.style.backgroundColor = '#ffffff';
                    container.appendChild(animationContainer);

                    // Initialize Lottie animation
                    console.log('Initializing Lottie animation for conversation TGS...');
                    const animation = lottie.loadAnimation({
                        container: animationContainer,
                        renderer: 'svg',
                        loop: true,
                        autoplay: true,
                        animationData: lottieJson
                    });
                    console.log('Lottie animation initialized successfully for conversation TGS');

                    // Handle animation errors
                            animation.addEventListener('error', (error) => {
                                console.error('Lottie animation error:', error);
                                container.innerHTML = `
                                    <div style="text-align: center; color: #dc3545;">
                                        <div style="font-size: 16px; margin-bottom: 5px;">⚠️</div>
                                        <div style="font-size: 11px;">Animation Error</div>
                                        <div style="font-size: 10px; margin-top: 5px;">${escapeHtml(error.message || 'Unknown error')}</div>
                                    </div>
                                `;
                            });

                    // Handle successful loading
                    animation.addEventListener('DOMLoaded', () => {
                        console.log('Lottie animation DOM loaded successfully for conversation TGS');
                    });

                } catch (error) {
                    if (error && error.message === 'unauthorized') {
                        return;
                    }
                    console.error(`Failed to load TGS animation for ${uniqueId} in conversation:`, error);
                    container.innerHTML = `
                        <div style="text-align: center; color: #dc3545;">
                            <div style="font-size: 16px; margin-bottom: 5px;">⚠️</div>
                            <div style="font-size: 11px;">Load Failed</div>
                            <div style="font-size: 10px; margin-top: 5px;">${escapeHtml(error.message || 'Unknown error')}</div>
                            <a href="${mediaUrl}" download style="color: #007bff; text-decoration: none; font-size: 10px; margin-top: 5px; display: block;">Download TGS</a>
                        </div>
                    `;
                }
            }
        }

        function triggerSummarization(agentName, userId, buttonElement) {
            if (!confirm('This will trigger summarization of the unsummarized messages. Continue?')) {
                return;
            }
            
            // Find the button's container
            const container = buttonElement.closest('div[style*="display: flex"]');
            
            const statusDiv = document.createElement('div');
            statusDiv.id = `summarize-status-${userId}`;
            statusDiv.style.cssText = 'margin-top: 8px; font-size: 14px; color: #007bff; width: 100%;';
            statusDiv.textContent = 'Triggering summarization...';
            
            // Insert status div after the container
            if (container && container.parentElement) {
                container.parentElement.insertBefore(statusDiv, container.nextSibling);
            }
            buttonElement.disabled = true;
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation/${userId}/summarize`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                const statusDiv = document.getElementById(`summarize-status-${userId}`);
                if (data.error) {
                    if (statusDiv) {
                        statusDiv.textContent = 'Error: ' + data.error;
                        statusDiv.style.color = '#dc3545';
                    }
                    buttonElement.disabled = false;
                } else {
                    if (statusDiv) {
                        statusDiv.textContent = 'Summarization task created! The conversation will be summarized in the next tick.';
                        statusDiv.style.color = '#28a745';
                    }
                    // Reload conversation after a short delay to show updated summaries
                    setTimeout(() => {
                        loadConversation();
                    }, 2000);
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                const statusDiv = document.getElementById(`summarize-status-${userId}`);
                if (statusDiv) {
                    statusDiv.textContent = 'Error: ' + error;
                    statusDiv.style.color = '#dc3545';
                }
                buttonElement.disabled = false;
            });
        }

        function deleteTelepathicMessages(agentName, userId, buttonElement) {
            // Note: This list should match TELEPATHIC_PREFIXES in src/telepathic.py
            if (!confirm('Are you sure you want to delete all telepathic messages (⟦think⟧, ⟦remember⟧, ⟦intend⟧, ⟦plan⟧, ⟦retrieve⟧, ⟦summarize⟧, ⟦xsend⟧, ⟦note⟧) from this channel? This action cannot be undone.')) {
                return;
            }
            
            // Disable button and show status
            buttonElement.disabled = true;
            const originalText = buttonElement.textContent;
            buttonElement.textContent = 'Deleting...';
            
            // Create or update status div
            let statusDiv = document.getElementById(`delete-telepathic-status-${userId}`);
            if (!statusDiv) {
                statusDiv = document.createElement('div');
                statusDiv.id = `delete-telepathic-status-${userId}`;
                statusDiv.style.marginTop = '8px';
                statusDiv.style.fontSize = '14px';
                buttonElement.parentElement.appendChild(statusDiv);
            }
            statusDiv.textContent = 'Deleting telepathic messages...';
            statusDiv.style.color = '#007bff';
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation/${userId}/delete-telepathic-messages`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    statusDiv.textContent = 'Error: ' + data.error;
                    statusDiv.style.color = '#dc3545';
                    buttonElement.disabled = false;
                    buttonElement.textContent = originalText;
                } else {
                    statusDiv.textContent = data.message || `Successfully deleted ${data.deleted_count || 0} telepathic message(s)`;
                    statusDiv.style.color = '#28a745';
                    buttonElement.disabled = false;
                    buttonElement.textContent = originalText;
                    // Reload conversation after a short delay to show updated messages
                    setTimeout(() => {
                        loadConversation();
                    }, 1000);
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                statusDiv.textContent = 'Error: ' + error;
                statusDiv.style.color = '#dc3545';
                buttonElement.disabled = false;
                buttonElement.textContent = originalText;
            });
        }

        function downloadConversation(agentName, userId, buttonElement) {
            // Disable button and show status
            buttonElement.disabled = true;
            const originalText = buttonElement.textContent;
            buttonElement.textContent = 'Preparing download...';
            
            // Create or update status div
            let statusDiv = document.getElementById(`download-status-${userId}`);
            if (!statusDiv) {
                statusDiv = document.createElement('div');
                statusDiv.id = `download-status-${userId}`;
                statusDiv.style.marginTop = '8px';
                statusDiv.style.fontSize = '14px';
                buttonElement.parentElement.appendChild(statusDiv);
            }
            statusDiv.textContent = 'Preparing download...';
            statusDiv.style.color = '#007bff';
            
            // Get translation setting
            const checkbox = document.getElementById('translation-toggle');
            const includeTranslations = checkbox ? checkbox.checked : false;
            
            // Make request to download endpoint
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation/${userId}/download`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    include_translations: includeTranslations
                })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.error || `HTTP ${response.status}`);
                    });
                }
                return response.blob();
            })
            .then(blob => {
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                a.download = `conversation_${agentName}_${userId}_${timestamp}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                statusDiv.textContent = 'Download complete!';
                statusDiv.style.color = '#28a745';
                buttonElement.disabled = false;
                buttonElement.textContent = originalText;
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                statusDiv.textContent = 'Error: ' + (error.message || error);
                statusDiv.style.color = '#dc3545';
                buttonElement.disabled = false;
                buttonElement.textContent = originalText;
            });
        }

        // Helper function to update a single message with translation
        function updateMessageTranslation(messageId, translatedText) {
            // Don't update if translation is disabled
            if (!showTranslation) return;
            
            const messageEl = document.getElementById(`message-${messageId}`);
            if (!messageEl) return;
            
            // Update the translation in our dictionary
            conversationTranslations[messageId] = translatedText;
            
            // Find all content divs with text (there might be multiple if message has parts)
            const contentDivs = messageEl.querySelectorAll('div[style*="white-space: pre-wrap"]');
            if (contentDivs.length > 0) {
                // Update the first text div (or all if there are multiple text parts)
                // For messages with parts, we typically only want to update the first text part
                // For simple messages, there's only one div
                contentDivs[0].innerHTML = translatedText;
            }
            
            // Update background color from grey to normal
            const msg = conversationMessages.find(m => String(m.id) === String(messageId));
            if (msg) {
                const bgColor = msg.is_from_agent ? '#e3f2fd' : 'white';
                messageEl.style.background = bgColor;
            }
        }
        
        // Track active translation stream for cancellation
        let translationAbortController = null;
        let translationStreamReader = null;
        let translationStreamTimeout = null;
        
        function toggleTranslation(agentName, userId) {
            const checkbox = document.getElementById('translation-toggle');
            if (!checkbox) return; // Checkbox not rendered (no unsummarized messages)
            showTranslation = checkbox.checked;
            
            // Cancel any pending timeout
            if (translationStreamTimeout) {
                clearTimeout(translationStreamTimeout);
                translationStreamTimeout = null;
            }
            
            // Cancel any active translation stream
            if (translationAbortController) {
                translationAbortController.abort();
                translationAbortController = null;
            }
            if (translationStreamReader) {
                translationStreamReader.cancel();
                translationStreamReader = null;
            }
            
            if (showTranslation) {
                // Check if all messages with text have translations
                const messagesWithText = conversationMessages.filter(msg => msg.text);
                const allHaveTranslations = messagesWithText.length > 0 && 
                    messagesWithText.every(msg => conversationTranslations[msg.id]);
                
                // If all messages with text already have translations, just re-render
                if (allHaveTranslations) {
                    fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation/${userId}`)
                        .then(response => response.json())
                        .then(data => {
                            if (!data.error) {
                                if (data.agent_timezone) {
                                    conversationAgentTimezone = data.agent_timezone;
                                }
                                const isBlocked = data.is_blocked || false;
                                renderConversation(agentName, userId, data.summaries || [], conversationMessages, conversationAgentTimezone, isBlocked);
                            }
                        });
                    return;
                }
                
                // Update background colors to grey for messages without translations
                // Do this without full re-render to avoid triggering image full-screen on mobile
                conversationMessages.forEach(msg => {
                    if (msg.text && !conversationTranslations[msg.id]) {
                        const messageEl = document.getElementById(`message-${msg.id}`);
                        if (messageEl) {
                            messageEl.style.background = '#e0e0e0';
                        }
                    }
                });
                
                // Start streaming translations via SSE
                // Use setTimeout to break the connection between touch event and DOM updates
                // This prevents mobile browsers from interpreting the updates as image clicks
                translationStreamTimeout = setTimeout(() => {
                    translationStreamTimeout = null;
                    startTranslationStream(agentName, userId, checkbox);
                }, 100);
            } else {
                // Just re-render with current translation state (translations hidden)
                fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation/${userId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (!data.error) {
                            if (data.agent_timezone) {
                                conversationAgentTimezone = data.agent_timezone;
                            }
                            const isBlocked = data.is_blocked || false;
                            renderConversation(agentName, userId, data.summaries || [], conversationMessages, conversationAgentTimezone, isBlocked);
                        }
                    });
            }
        }
        
        function startTranslationStream(agentName, userId, checkbox) {
            // Early return if translation was disabled before this function was called
            if (!showTranslation) {
                return;
            }
            
            // Cancel any existing stream first
            if (translationAbortController) {
                translationAbortController.abort();
            }
            if (translationStreamReader) {
                translationStreamReader.cancel();
            }
            
            // Create new AbortController for this stream
            translationAbortController = new AbortController();
            const abortSignal = translationAbortController.signal;
            
            // Build the URL for SSE endpoint
            const url = `${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation/${userId}/translate`;
            
            // Create POST request body
            const requestBody = JSON.stringify({ messages: conversationMessages });
            
            // Use fetch with ReadableStream to handle SSE (EventSource doesn't support POST)
            fetchWithAuth(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: requestBody,
                signal: abortSignal
            })
            .then(response => {
                if (!response.ok) {
                    // Try to parse error as JSON
                    // Handle JSON parsing errors first, then handle successful parse
                    return response.json()
                        .catch(() => {
                            // JSON parsing failed, throw generic error
                            throw new Error(`HTTP error! status: ${response.status}`);
                        })
                        .then(data => {
                            // JSON parsing succeeded, throw with the error message from the server
                            throw new Error(data.error || `HTTP error! status: ${response.status}`);
                        });
                }
                
                // Check if response is SSE (text/event-stream)
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('text/event-stream')) {
                    // Handle SSE stream
                    const reader = response.body.getReader();
                    translationStreamReader = reader; // Store reader for cancellation
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    function readStream() {
                        // Check if translation was disabled before continuing
                        if (!showTranslation || abortSignal.aborted) {
                            reader.cancel();
                            translationStreamReader = null;
                            translationAbortController = null;
                            return;
                        }
                        
                        reader.read().then(({ done, value }) => {
                            if (done) {
                                // Stream completed - process any remaining buffer
                                if (buffer.trim() && showTranslation && !abortSignal.aborted) {
                                    const events = buffer.split('\n\n');
                                    for (const event of events) {
                                        if (event.trim()) {
                                            const lines = event.split('\n');
                                            for (const line of lines) {
                                                if (line.startsWith('data: ')) {
                                                    try {
                                                        const data = JSON.parse(line.slice(6));
                                                        handleTranslationEvent(data, checkbox);
                                                    } catch (e) {
                                                        console.error('Error parsing SSE data:', e, line);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                translationStreamReader = null;
                                translationAbortController = null;
                                return;
                            }
                            
                            // Check again if translation was disabled
                            if (!showTranslation || abortSignal.aborted) {
                                reader.cancel();
                                translationStreamReader = null;
                                translationAbortController = null;
                                return;
                            }
                            
                            buffer += decoder.decode(value, { stream: true });
                            // SSE events are separated by double newlines
                            const events = buffer.split('\n\n');
                            // Keep the last incomplete event in buffer
                            buffer = events.pop() || '';
                            
                            for (const event of events) {
                                if (event.trim() && showTranslation && !abortSignal.aborted) {
                                    // Parse SSE event (format: "data: {...}")
                                    const lines = event.split('\n');
                                    for (const line of lines) {
                                        if (line.startsWith('data: ')) {
                                            try {
                                                const data = JSON.parse(line.slice(6));
                                                handleTranslationEvent(data, checkbox);
                                            } catch (e) {
                                                console.error('Error parsing SSE data:', e, line);
                                            }
                                        }
                                    }
                                }
                            }
                            
                            readStream();
                        }).catch(error => {
                            // Clean up on error
                            translationStreamReader = null;
                            translationAbortController = null;
                            
                            console.error('Error reading stream:', error);
                            if (error && error.message !== 'unauthorized') {
                                // Only show alert for unexpected errors (not cancellation)
                                if (!error.message.includes('aborted') && !error.message.includes('canceled')) {
                                    alert('Error receiving translations: ' + error);
                                    if (checkbox) {
                                        checkbox.checked = false;
                                    }
                                    showTranslation = false;
                                }
                            }
                        });
                    }
                    
                    readStream();
                } else {
                    // Fallback: try to parse as JSON (for backward compatibility)
                    return response.json();
                }
            })
            .then(data => {
                // Only reached if response was JSON (not SSE)
                if (data && data.error) {
                    alert('Error translating messages: ' + data.error);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                    showTranslation = false;
                } else if (data && data.translations) {
                    // Handle non-streaming response (backward compatibility)
                    Object.assign(conversationTranslations, data.translations);
                    // Re-render to show translations
                    fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/conversation/${userId}`)
                        .then(response => response.json())
                        .then(data => {
                            if (!data.error) {
                                if (data.agent_timezone) {
                                    conversationAgentTimezone = data.agent_timezone;
                                }
                                renderConversation(agentName, userId, data.summaries || [], conversationMessages, conversationAgentTimezone);
                            }
                        });
                }
            })
            .catch(error => {
                // Clean up on error
                translationStreamReader = null;
                translationAbortController = null;
                
                if (error && error.message === 'unauthorized') {
                    return;
                }
                console.error('Translation stream error:', error);
                // Show alert for fetch errors (not stream read errors or aborts)
                if (error.name !== 'AbortError' && error.message && !error.message.includes('aborted') && !error.message.includes('canceled')) {
                    alert('Error translating messages: ' + error.message);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                    showTranslation = false;
                }
            });
        }
        
        function handleTranslationEvent(data, checkbox) {
            // Don't process events if translation is disabled
            if (!showTranslation) return;
            
            if (data.type === 'cached') {
                // Initial cached translations
                Object.assign(conversationTranslations, data.translations || {});
                // Update all cached translations in the UI
                for (const [messageId, translatedText] of Object.entries(data.translations || {})) {
                    updateMessageTranslation(messageId, translatedText);
                }
            } else if (data.type === 'translation') {
                // New translations from a batch
                for (const [messageId, translatedText] of Object.entries(data.translations || {})) {
                    updateMessageTranslation(messageId, translatedText);
                }
            } else if (data.type === 'complete') {
                // Translation complete
                console.log('Translation stream completed');
                translationStreamReader = null;
                translationAbortController = null;
            } else if (data.type === 'error') {
                // Error occurred
                translationStreamReader = null;
                translationAbortController = null;
                alert('Error translating messages: ' + (data.error || 'Unknown error'));
                if (checkbox) {
                    checkbox.checked = false;
                }
                showTranslation = false;
            }
        }


        // Set up conversation partner select change handlers
        document.getElementById('notes-params-partner-select')?.addEventListener('change', (e) => {
            if (e.target.value) {
                document.getElementById('notes-params-user-id').value = '';
                loadNotesForPartner();
            }
        });

        document.getElementById('conversation-llm-partner-select')?.addEventListener('change', (e) => {
            if (e.target.value) {
                document.getElementById('conversation-llm-user-id').value = '';
                loadConversationLLM();
            }
        });

        document.getElementById('plans-partner-select')?.addEventListener('change', (e) => {
            if (e.target.value) {
                document.getElementById('plans-user-id').value = '';
                loadPlans();
            }
        });

        document.getElementById('conversation-partner-select')?.addEventListener('change', (e) => {
            if (e.target.value) {
                document.getElementById('conversation-user-id').value = '';
                loadConversation();
            }
        });

        // XSend functionality
        function sendXSend() {
            const agentSelect = document.getElementById('conversations-agent-select');
            const partnerSelect = document.getElementById('conversations-partner-select');
            const userIdInput = document.getElementById('conversations-user-id');
            const intentTextarea = document.getElementById('xsend-intent-textarea');
            const statusDiv = document.getElementById('xsend-status');
            
            const agentName = agentSelect?.value;
            const userId = userIdInput?.value.trim() || partnerSelect?.value;
            const intent = intentTextarea?.value.trim() || '';
            
            if (!agentName) {
                statusDiv.innerHTML = '<div style="color: #dc3545;">Please select an agent</div>';
                return;
            }
            
            if (!userId) {
                statusDiv.innerHTML = '<div style="color: #dc3545;">Please select or enter a conversation partner</div>';
                return;
            }
            
            if (!intent) {
                statusDiv.innerHTML = '<div style="color: #dc3545;">Please enter an intent message</div>';
                return;
            }
            
            statusDiv.innerHTML = '<div style="color: #007bff;">Sending...</div>';
            
            fetchWithAuth(`${API_BASE}/agents/${encodeURIComponent(agentName)}/xsend/${userId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ intent: intent })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    statusDiv.innerHTML = `<div style="color: #dc3545;">Error: ${escapeHtml(data.error)}</div>`;
                } else {
                    statusDiv.innerHTML = '<div style="color: #28a745;">XSend task created successfully!</div>';
                    intentTextarea.value = '';
                }
            })
            .catch(error => {
                if (error && error.message === 'unauthorized') {
                    return;
                }
                statusDiv.innerHTML = `<div style="color: #dc3545;">Error: ${escapeHtml(error)}</div>`;
            });
        }

        // Initialize on page load
        loadAgents();
        
        // ===== Docs Management Functions =====
        
        // Global docs state
        let globalDocsConfigDir = '';
        let globalDocsCurrentFilename = '';
        let globalDocsSaveTimeout = null;
        let globalDocsFilenameTimeout = null;
        let globalDocsContent = '';
        
        // Agent docs state
        let agentDocsCurrentAgent = '';
        let agentDocsCurrentFilename = '';
        let agentDocsSaveTimeout = null;
        let agentDocsFilenameTimeout = null;
        let agentDocsContent = '';
        
        // Load config directories for global docs
        async function loadGlobalDocsConfigDirectories() {
            try {
                const response = await fetch('/admin/api/config-directories');
                const data = await response.json();
                
                const select = document.getElementById('global-docs-config-select');
                if (!select) return;
                
                select.innerHTML = '<option value="">Choose a config directory...</option>';
                data.directories.forEach(dir => {
                    const option = document.createElement('option');
                    option.value = dir.path;
                    option.textContent = dir.display_path;
                    select.appendChild(option);
                });
                
                select.onchange = function() {
                    globalDocsConfigDir = this.value;
                    // Clear the currently loaded document when directory changes
                    globalDocsCurrentFilename = '';
                    globalDocsContent = '';
                    document.getElementById('global-docs-select').innerHTML = '<option value="">Choose a document...</option>';
                    document.getElementById('global-docs-editor-container').innerHTML = '<div class="loading">Select a config directory and document to edit</div>';
                    document.getElementById('delete-global-doc-btn').style.display = 'none';
                    // Load docs list (will show all if no directory selected)
                    loadGlobalDocsList();
                };
                
                // Load docs list on initial load (will show all if no directory selected)
                loadGlobalDocsList();
            } catch (error) {
                console.error('Error loading config directories:', error);
            }
        }
        
        // Load list of docs for global docs
        async function loadGlobalDocsList() {
            try {
                // If no config directory is selected, fetch from all directories
                const url = globalDocsConfigDir 
                    ? `/admin/api/docs?config_dir=${encodeURIComponent(globalDocsConfigDir)}`
                    : '/admin/api/docs';
                
                const response = await fetch(url);
                const data = await response.json();
                
                const select = document.getElementById('global-docs-select');
                if (!select) return;
                
                select.innerHTML = '<option value="">Choose a document...</option>';
                
                // Get config directory display paths for labeling
                let configDirDisplayMap = {};
                if (!globalDocsConfigDir) {
                    const configDirsResponse = await fetch('/admin/api/config-directories');
                    const configDirsData = await configDirsResponse.json();
                    configDirDisplayMap = {};
                    configDirsData.directories.forEach(dir => {
                        configDirDisplayMap[dir.path] = dir.display_path;
                    });
                }
                
                data.docs.forEach(doc => {
                    const option = document.createElement('option');
                    option.value = doc.filename;
                    // Store config_dir in data attribute
                    option.dataset.configDir = doc.config_dir || globalDocsConfigDir;
                    
                    // Display filename with source directory if showing all directories
                    if (!globalDocsConfigDir && doc.config_dir) {
                        const displayPath = configDirDisplayMap[doc.config_dir] || doc.config_dir;
                        option.textContent = `${doc.filename} (from ${displayPath})`;
                    } else {
                        option.textContent = doc.filename;
                    }
                    select.appendChild(option);
                });
                
                select.onchange = function() {
                    if (this.value) {
                        const selectedOption = this.options[this.selectedIndex];
                        const docConfigDir = selectedOption.dataset.configDir;
                        
                        // Always update config directory to match the selected item's directory
                        if (docConfigDir && docConfigDir !== globalDocsConfigDir) {
                            const configSelect = document.getElementById('global-docs-config-select');
                            if (configSelect) {
                                configSelect.value = docConfigDir;
                                globalDocsConfigDir = docConfigDir;
                            }
                        }
                        
                        loadGlobalDoc(this.value);
                    } else {
                        document.getElementById('global-docs-editor-container').innerHTML = '<div class="loading">Select a document to edit</div>';
                        document.getElementById('delete-global-doc-btn').style.display = 'none';
                    }
                };
            } catch (error) {
                console.error('Error loading docs list:', error);
            }
        }
        
        // Load a specific global doc
        async function loadGlobalDoc(filename) {
            if (!globalDocsConfigDir || !filename) return;
            
            try {
                const response = await fetch(`/admin/api/docs/${encodeURIComponent(filename)}?config_dir=${encodeURIComponent(globalDocsConfigDir)}`);
                if (!response.ok) {
                    throw new Error('Failed to load doc');
                }
                
                const data = await response.json();
                globalDocsCurrentFilename = filename;
                globalDocsContent = data.content || '';
                
                renderGlobalDocEditor(data.content || '', filename, globalDocsConfigDir);
                document.getElementById('delete-global-doc-btn').style.display = 'inline-block';
            } catch (error) {
                console.error('Error loading doc:', error);
                document.getElementById('global-docs-editor-container').innerHTML = '<div class="error">Error loading document</div>';
            }
        }
        
        // Render global doc editor
        function renderGlobalDocEditor(content, filename, configDir) {
            const container = document.getElementById('global-docs-editor-container');
            container.innerHTML = `
                <div style="background: white; padding: 16px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Filename:</label>
                        <input type="text" id="global-docs-filename" value="${escapeHtml(filename)}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;" />
                        <div id="global-docs-filename-status" style="margin-top: 4px; font-size: 12px; color: #666;"></div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Move to:</label>
                        <select id="global-docs-move-destination" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                            <option value="">Move to...</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Content:</label>
                        <textarea id="global-docs-content" style="width: 100%; min-height: 400px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 14px;">${escapeHtml(content)}</textarea>
                        <div id="global-docs-save-status" style="margin-top: 4px; font-size: 12px; color: #666;"></div>
                    </div>
                </div>
            `;
            
            // Setup handlers
            // Capture all state at creation time to avoid race conditions
            const filenameInput = document.getElementById('global-docs-filename');
            filenameInput.oninput = debounceGlobalDocsFilename(configDir, filename);
            
            // Setup content change handler with auto-save
            const contentTextarea = document.getElementById('global-docs-content');
            contentTextarea.oninput = debounceGlobalDocsSave(configDir, filename);
            
            // Setup move destination change handler
            const moveSelect = document.getElementById('global-docs-move-destination');
            moveSelect.onchange = function() {
                if (this.value) {
                    moveGlobalDoc();
                }
            };
            
            // Load all destinations for move dropdown
            loadAllDestinationsForMove('global-docs-move-destination', globalDocsConfigDir, null);
        }
        
        // Debounced save for global docs
        // Captures configDir and filename to avoid race conditions
        function debounceGlobalDocsSave(configDir, filename) {
            return function() {
                if (globalDocsSaveTimeout) {
                    clearTimeout(globalDocsSaveTimeout);
                }
                
                const statusEl = document.getElementById('global-docs-save-status');
                if (statusEl) statusEl.textContent = 'Typing...';
                
                globalDocsSaveTimeout = setTimeout(async () => {
                    // Verify we're still editing the same document (user may have switched)
                    if (globalDocsConfigDir !== configDir || globalDocsCurrentFilename !== filename) {
                        // User switched documents, don't save
                        if (statusEl) statusEl.textContent = '';
                        return;
                    }
                    
                    const contentTextarea = document.getElementById('global-docs-content');
                    if (!contentTextarea) return;
                    
                    const newContent = contentTextarea.value;
                    if (newContent === globalDocsContent) {
                        if (statusEl) statusEl.textContent = 'Saved';
                        return;
                    }
                    
                    if (statusEl) statusEl.textContent = 'Saving...';
                    
                    try {
                        // Use captured values instead of reading from globals
                        const response = await fetch(`/admin/api/docs/${encodeURIComponent(filename)}?config_dir=${encodeURIComponent(configDir)}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ content: newContent })
                        });
                        
                        if (response.ok) {
                            globalDocsContent = newContent;
                            if (statusEl) statusEl.textContent = 'Saved';
                        } else {
                            throw new Error('Save failed');
                        }
                    } catch (error) {
                        console.error('Error saving doc:', error);
                        if (statusEl) statusEl.textContent = 'Error saving';
                    }
                }, 1000);
            };
        }
        
        // Debounced filename change for global docs
        // Captures configDir and filename to avoid race conditions
        function debounceGlobalDocsFilename(configDir, filename) {
            return function() {
                if (globalDocsFilenameTimeout) {
                    clearTimeout(globalDocsFilenameTimeout);
                }
                
                const filenameInput = document.getElementById('global-docs-filename');
                if (!filenameInput) return;
                
                const newFilename = filenameInput.value.trim();
                const statusEl = document.getElementById('global-docs-filename-status');
                
                // Verify we're still editing the same document (user may have switched)
                if (globalDocsConfigDir !== configDir || globalDocsCurrentFilename !== filename) {
                    // User switched documents, don't rename
                    if (statusEl) statusEl.textContent = '';
                    return;
                }
                
                if (!newFilename || newFilename === filename) {
                    if (statusEl) statusEl.textContent = '';
                    return;
                }
                
                if (!newFilename.endsWith('.md')) {
                    if (statusEl) statusEl.textContent = 'Filename must end with .md';
                    return;
                }
                
                if (statusEl) statusEl.textContent = 'Renaming...';
                
                globalDocsFilenameTimeout = setTimeout(async () => {
                    // Double-check we're still editing the same document before renaming
                    if (globalDocsConfigDir !== configDir || globalDocsCurrentFilename !== filename) {
                        // User switched documents, don't rename
                        if (statusEl) statusEl.textContent = '';
                        return;
                    }
                    
                    try {
                        // Use captured values instead of reading from globals
                        const response = await fetch(`/admin/api/docs/${encodeURIComponent(filename)}/rename?config_dir=${encodeURIComponent(configDir)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ new_filename: newFilename })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            const newFilename = data.filename;
                            globalDocsCurrentFilename = newFilename;
                            
                            // Update handlers with new filename to allow further saves/renames
                            const contentTextarea = document.getElementById('global-docs-content');
                            if (contentTextarea) {
                                contentTextarea.oninput = debounceGlobalDocsSave(configDir, newFilename);
                            }
                            const filenameInput = document.getElementById('global-docs-filename');
                            if (filenameInput) {
                                filenameInput.oninput = debounceGlobalDocsFilename(configDir, newFilename);
                            }

                            // Refresh the document list dropdown
                            loadGlobalDocsList().then(() => {
                                document.getElementById('global-docs-select').value = newFilename;
                            });
                            if (statusEl) statusEl.textContent = 'Renamed';
                            setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 2000);
                        } else {
                            throw new Error('Rename failed');
                        }
                    } catch (error) {
                        console.error('Error renaming doc:', error);
                        if (statusEl) statusEl.textContent = 'Error renaming';
                    }
                }, 1000);
            };
        }
        
        // Create new global doc
        async function createGlobalDoc() {
            if (!globalDocsConfigDir) {
                alert('Please select a config directory first');
                return;
            }

            // Find a unique filename
            let filename = 'Untitled.md';
            let counter = 1;
            try {
                // Load existing docs to check for conflicts
                const response = await fetch(`/admin/api/docs?config_dir=${encodeURIComponent(globalDocsConfigDir)}`);
                const data = await response.json();
                const existingFilenames = new Set(data.docs.map(doc => doc.filename));
                
                while (existingFilenames.has(filename)) {
                    filename = `Untitled-${counter}.md`;
                    counter++;
                }
            } catch (error) {
                console.error('Error checking existing docs:', error);
                // Continue with Untitled.md, will fail if it exists
            }

            try {
                const response = await fetch(`/admin/api/docs/${encodeURIComponent(filename)}?config_dir=${encodeURIComponent(globalDocsConfigDir)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: '' })
                });

                if (response.ok) {
                    loadGlobalDocsList().then(() => {
                        document.getElementById('global-docs-select').value = filename;
                    });
                    loadGlobalDoc(filename);
                } else {
                    throw new Error('Create failed');
                }
            } catch (error) {
                console.error('Error creating doc:', error);
                alert('Error creating document');
            }
        }
        
        // Delete global doc
        async function deleteGlobalDoc() {
            if (!globalDocsCurrentFilename || !confirm(`Delete ${globalDocsCurrentFilename}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/admin/api/docs/${encodeURIComponent(globalDocsCurrentFilename)}?config_dir=${encodeURIComponent(globalDocsConfigDir)}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    loadGlobalDocsList();
                    document.getElementById('global-docs-select').value = '';
                    document.getElementById('global-docs-editor-container').innerHTML = '<div class="loading">Select a document to edit</div>';
                    document.getElementById('delete-global-doc-btn').style.display = 'none';
                    globalDocsCurrentFilename = '';
                } else {
                    throw new Error('Delete failed');
                }
            } catch (error) {
                console.error('Error deleting doc:', error);
                alert('Error deleting document');
            }
        }
        
        // Move global doc
        async function moveGlobalDoc() {
            if (!globalDocsCurrentFilename) return;

            const destinationValue = document.getElementById('global-docs-move-destination').value;
            if (!destinationValue) {
                return;
            }

            // Parse destination value: "global|config_dir" or "agent|config_dir|agent_config_name"
            let toConfigDir, toAgentConfigName;
            if (destinationValue.startsWith('global|')) {
                toConfigDir = destinationValue.substring(7); // Remove "global|" prefix
                toAgentConfigName = null;
            } else if (destinationValue.startsWith('agent|')) {
                const parts = destinationValue.substring(6).split('|'); // Remove "agent|" prefix
                toConfigDir = parts[0] || '';
                toAgentConfigName = parts[1] || '';
            } else {
                return;
            }

            // Check if it's the current location
            if (!toAgentConfigName && toConfigDir === globalDocsConfigDir) {
                return; // Already at this location
            }

            if (!toConfigDir) {
                alert('Invalid destination');
                return;
            }

            if (destinationValue.startsWith('agent|') && !toAgentConfigName) {
                alert('Invalid agent destination');
                return;
            }

            if (!confirm(`Move ${globalDocsCurrentFilename} to ${destinationValue.startsWith('agent|') ? 'agent docs' : 'global docs'}?`)) {
                // Reset dropdown to current location
                loadAllDestinationsForMove('global-docs-move-destination', globalDocsConfigDir, null);
                return;
            }

            try {
                const response = await fetch(`/admin/api/docs/${encodeURIComponent(globalDocsCurrentFilename)}/move?from_config_dir=${encodeURIComponent(globalDocsConfigDir)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        to_config_dir: toConfigDir,
                        to_agent_config_name: toAgentConfigName
                    })
                });

                if (response.ok) {
                    loadGlobalDocsList();
                    document.getElementById('global-docs-select').value = '';
                    document.getElementById('global-docs-editor-container').innerHTML = '<div class="loading">Select a document to edit</div>';
                    document.getElementById('delete-global-doc-btn').style.display = 'none';
                    globalDocsCurrentFilename = '';
                    alert('Document moved successfully');
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Move failed');
                }
            } catch (error) {
                console.error('Error moving doc:', error);
                alert(`Error moving document: ${error.message}`);
                // Reset dropdown to current location
                loadAllDestinationsForMove('global-docs-move-destination', globalDocsConfigDir, null);
            }
        }
        
        // Load agent docs list
        async function loadAgentDocs(agentConfigName) {
            if (!agentConfigName) {
                document.getElementById('agent-docs-select').innerHTML = '<option value="">Choose a document...</option>';
                document.getElementById('agent-docs-editor-container').innerHTML = '<div class="loading">Select an agent and document to edit</div>';
                return;
            }
            
            agentDocsCurrentAgent = agentConfigName;
            
            try {
                // Get agent to find its config directory
                const agentsResponse = await fetch('/admin/api/agents');
                const agentsData = await agentsResponse.json();
                const agent = agentsData.agents.find(a => a.config_name === agentConfigName);
                
                if (!agent) {
                    throw new Error('Agent not found');
                }
                
                // Get config directory from agent (should be stored in agent object)
                // For now, we'll need to search through config directories
                // Actually, the agent should have config_directory property
                // Get config directory from agent or use first available
                let configDir = agent.config_directory;
                if (!configDir) {
                    const configDirsResponse = await fetch('/admin/api/config-directories');
                    const configDirsData = await configDirsResponse.json();
                    configDir = configDirsData.directories[0]?.path || '';
                }
                
                const response = await fetch(`/admin/api/docs?config_dir=${encodeURIComponent(configDir)}&agent_config_name=${encodeURIComponent(agentConfigName)}`);
                const data = await response.json();
                
                const select = document.getElementById('agent-docs-select');
                if (!select) return;
                
                select.innerHTML = '<option value="">Choose a document...</option>';
                data.docs.forEach(doc => {
                    const option = document.createElement('option');
                    option.value = doc.filename;
                    option.textContent = doc.filename;
                    select.appendChild(option);
                });
                
                select.onchange = function() {
                    if (this.value) {
                        loadAgentDoc(this.value, configDir);
                    } else {
                        document.getElementById('agent-docs-editor-container').innerHTML = '<div class="loading">Select a document to edit</div>';
                        document.getElementById('delete-agent-doc-btn').style.display = 'none';
                    }
                };
            } catch (error) {
                console.error('Error loading agent docs list:', error);
            }
        }
        
        // Load a specific agent doc
        async function loadAgentDoc(filename, configDir) {
            if (!agentDocsCurrentAgent || !filename) return;
            
            try {
                const response = await fetch(`/admin/api/docs/${encodeURIComponent(filename)}?config_dir=${encodeURIComponent(configDir)}&agent_config_name=${encodeURIComponent(agentDocsCurrentAgent)}`);
                if (!response.ok) {
                    throw new Error('Failed to load doc');
                }
                
                const data = await response.json();
                agentDocsCurrentFilename = filename;
                agentDocsContent = data.content || '';
                
                renderAgentDocEditor(data.content || '', filename, configDir);
                document.getElementById('delete-agent-doc-btn').style.display = 'inline-block';
            } catch (error) {
                console.error('Error loading agent doc:', error);
                document.getElementById('agent-docs-editor-container').innerHTML = '<div class="error">Error loading document</div>';
            }
        }
        
        // Render agent doc editor (similar to global but with agent context)
        function renderAgentDocEditor(content, filename, configDir) {
            const container = document.getElementById('agent-docs-editor-container');
            container.innerHTML = `
                <div style="background: white; padding: 16px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Filename:</label>
                        <input type="text" id="agent-docs-filename" value="${escapeHtml(filename)}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;" />
                        <div id="agent-docs-filename-status" style="margin-top: 4px; font-size: 12px; color: #666;"></div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Move to:</label>
                        <select id="agent-docs-move-destination" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                            <option value="">Move to...</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Content:</label>
                        <textarea id="agent-docs-content" style="width: 100%; min-height: 400px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 14px;">${escapeHtml(content)}</textarea>
                        <div id="agent-docs-save-status" style="margin-top: 4px; font-size: 12px; color: #666;"></div>
                    </div>
                </div>
            `;
            
            // Setup handlers (similar to global docs)
            // Capture all state at creation time to avoid race conditions
            const filenameInput = document.getElementById('agent-docs-filename');
            filenameInput.oninput = debounceAgentDocsFilename(configDir, agentDocsCurrentAgent, filename);

            const contentTextarea = document.getElementById('agent-docs-content');
            contentTextarea.oninput = debounceAgentDocsSave(configDir, agentDocsCurrentAgent, filename);

            // Setup move destination change handler
            const moveSelect = document.getElementById('agent-docs-move-destination');
            moveSelect.onchange = function() {
                if (this.value) {
                    moveAgentDoc(configDir);
                }
            };

            // Load all destinations for move dropdown
            loadAllDestinationsForMove('agent-docs-move-destination', configDir, agentDocsCurrentAgent);
        }
        
        // Debounced save for agent docs
        // Captures configDir, agentConfigName, and filename to avoid race conditions
        function debounceAgentDocsSave(configDir, agentConfigName, filename) {
            return function() {
                if (agentDocsSaveTimeout) {
                    clearTimeout(agentDocsSaveTimeout);
                }
                
                const statusEl = document.getElementById('agent-docs-save-status');
                if (statusEl) statusEl.textContent = 'Typing...';
                
                agentDocsSaveTimeout = setTimeout(async () => {
                    // Verify we're still editing the same document (user may have switched)
                    if (agentDocsCurrentAgent !== agentConfigName || agentDocsCurrentFilename !== filename) {
                        // User switched agents/documents, don't save
                        if (statusEl) statusEl.textContent = '';
                        return;
                    }
                    
                    const contentTextarea = document.getElementById('agent-docs-content');
                    if (!contentTextarea) return;
                    
                    const newContent = contentTextarea.value;
                    if (newContent === agentDocsContent) {
                        if (statusEl) statusEl.textContent = 'Saved';
                        return;
                    }
                    
                    if (statusEl) statusEl.textContent = 'Saving...';
                    
                    try {
                        // Use captured values instead of reading from globals
                        const response = await fetch(`/admin/api/docs/${encodeURIComponent(filename)}?config_dir=${encodeURIComponent(configDir)}&agent_config_name=${encodeURIComponent(agentConfigName)}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ content: newContent })
                        });
                        
                        if (response.ok) {
                            agentDocsContent = newContent;
                            if (statusEl) statusEl.textContent = 'Saved';
                        } else {
                            throw new Error('Save failed');
                        }
                    } catch (error) {
                        console.error('Error saving agent doc:', error);
                        if (statusEl) statusEl.textContent = 'Error saving';
                    }
                }, 1000);
            };
        }
        
        // Debounced filename change for agent docs
        // Captures configDir, agentConfigName, and filename to avoid race conditions
        function debounceAgentDocsFilename(configDir, agentConfigName, filename) {
            return function() {
                if (agentDocsFilenameTimeout) {
                    clearTimeout(agentDocsFilenameTimeout);
                }
                
                const filenameInput = document.getElementById('agent-docs-filename');
                if (!filenameInput) return;
                
                const newFilename = filenameInput.value.trim();
                const statusEl = document.getElementById('agent-docs-filename-status');
                
                // Verify we're still editing the same document (user may have switched)
                if (agentDocsCurrentAgent !== agentConfigName || agentDocsCurrentFilename !== filename) {
                    // User switched agents/documents, don't rename
                    if (statusEl) statusEl.textContent = '';
                    return;
                }
                
                if (!newFilename || newFilename === filename) {
                    if (statusEl) statusEl.textContent = '';
                    return;
                }
                
                if (!newFilename.endsWith('.md')) {
                    if (statusEl) statusEl.textContent = 'Filename must end with .md';
                    return;
                }
                
                if (statusEl) statusEl.textContent = 'Renaming...';
                
                agentDocsFilenameTimeout = setTimeout(async () => {
                    // Double-check we're still editing the same document before renaming
                    if (agentDocsCurrentAgent !== agentConfigName || agentDocsCurrentFilename !== filename) {
                        // User switched agents/documents, don't rename
                        if (statusEl) statusEl.textContent = '';
                        return;
                    }
                    
                    try {
                        // Use captured values instead of reading from globals
                        const response = await fetch(`/admin/api/docs/${encodeURIComponent(filename)}/rename?config_dir=${encodeURIComponent(configDir)}&agent_config_name=${encodeURIComponent(agentConfigName)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ new_filename: newFilename })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            const newFilename = data.filename;
                            agentDocsCurrentFilename = newFilename;
                            
                            // Update handlers with new filename to allow further saves/renames
                            const contentTextarea = document.getElementById('agent-docs-content');
                            if (contentTextarea) {
                                contentTextarea.oninput = debounceAgentDocsSave(configDir, agentConfigName, newFilename);
                            }
                            const filenameInput = document.getElementById('agent-docs-filename');
                            if (filenameInput) {
                                filenameInput.oninput = debounceAgentDocsFilename(configDir, agentConfigName, newFilename);
                            }

                            // Refresh the document list dropdown
                            loadAgentDocs(agentConfigName).then(() => {
                                document.getElementById('agent-docs-select').value = newFilename;
                            });
                            if (statusEl) statusEl.textContent = 'Renamed';
                            setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 2000);
                        } else {
                            throw new Error('Rename failed');
                        }
                    } catch (error) {
                        console.error('Error renaming agent doc:', error);
                        if (statusEl) statusEl.textContent = 'Error renaming';
                    }
                }, 1000);
            };
        }
        
        // Create new agent doc
        async function createAgentDoc() {
            const agentSelect = document.getElementById('agents-agent-select');
            const agentConfigName = agentSelect ? stripAsterisk(agentSelect.value) : null;

            if (!agentConfigName) {
                alert('Please select an agent first');
                return;
            }

            // Find a unique filename
            let filename = 'Untitled.md';
            let counter = 1;
            try {
                const agentsResponse = await fetch('/admin/api/agents');
                const agentsData = await agentsResponse.json();
                const agent = agentsData.agents.find(a => a.config_name === agentConfigName);
                
                // Get config directory from agent or use first available
                let configDir = agent?.config_directory;
                if (!configDir) {
                    const configDirsResponse = await fetch('/admin/api/config-directories');
                    const configDirsData = await configDirsResponse.json();
                    configDir = configDirsData.directories[0]?.path || '';
                }

                // Load existing docs to check for conflicts
                const docsResponse = await fetch(`/admin/api/docs?config_dir=${encodeURIComponent(configDir)}&agent_config_name=${encodeURIComponent(agentConfigName)}`);
                const docsData = await docsResponse.json();
                const existingFilenames = new Set(docsData.docs.map(doc => doc.filename));
                
                while (existingFilenames.has(filename)) {
                    filename = `Untitled-${counter}.md`;
                    counter++;
                }

                const response = await fetch(`/admin/api/docs/${encodeURIComponent(filename)}?config_dir=${encodeURIComponent(configDir)}&agent_config_name=${encodeURIComponent(agentConfigName)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: '' })
                });

                if (response.ok) {
                    loadAgentDocs(agentConfigName).then(() => {
                        document.getElementById('agent-docs-select').value = filename;
                    });
                    loadAgentDoc(filename, configDir);
                } else {
                    throw new Error('Create failed');
                }
            } catch (error) {
                console.error('Error creating agent doc:', error);
                alert('Error creating document');
            }
        }
        
        // Delete agent doc
        async function deleteAgentDoc() {
            if (!agentDocsCurrentFilename || !agentDocsCurrentAgent) return;
            
            if (!confirm(`Delete ${agentDocsCurrentFilename}?`)) {
                return;
            }
            
            try {
                const agentsResponse = await fetch('/admin/api/agents');
                const agentsData = await agentsResponse.json();
                const agent = agentsData.agents.find(a => a.config_name === agentDocsCurrentAgent);
                
                // Get config directory from agent or use first available
                let configDir = agent?.config_directory;
                if (!configDir) {
                    const configDirsResponse = await fetch('/admin/api/config-directories');
                    const configDirsData = await configDirsResponse.json();
                    configDir = configDirsData.directories[0]?.path || '';
                }
                
                const response = await fetch(`/admin/api/docs/${encodeURIComponent(agentDocsCurrentFilename)}?config_dir=${encodeURIComponent(configDir)}&agent_config_name=${encodeURIComponent(agentDocsCurrentAgent)}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    loadAgentDocs(agentDocsCurrentAgent);
                    document.getElementById('agent-docs-select').value = '';
                    document.getElementById('agent-docs-editor-container').innerHTML = '<div class="loading">Select a document to edit</div>';
                    document.getElementById('delete-agent-doc-btn').style.display = 'none';
                    agentDocsCurrentFilename = '';
                } else {
                    throw new Error('Delete failed');
                }
            } catch (error) {
                console.error('Error deleting agent doc:', error);
                alert('Error deleting document');
            }
        }
        
        // Move agent doc
        async function moveAgentDoc(fromConfigDir) {
            if (!agentDocsCurrentFilename || !agentDocsCurrentAgent) return;

            const destinationValue = document.getElementById('agent-docs-move-destination').value;
            if (!destinationValue) {
                return;
            }

            // Parse destination value: "global|config_dir" or "agent|config_dir|agent_config_name"
            let toConfigDir, toAgentConfigName;
            if (destinationValue.startsWith('global|')) {
                toConfigDir = destinationValue.substring(7); // Remove "global|" prefix
                toAgentConfigName = null;
            } else if (destinationValue.startsWith('agent|')) {
                const parts = destinationValue.substring(6).split('|'); // Remove "agent|" prefix
                toConfigDir = parts[0] || '';
                toAgentConfigName = parts[1] || '';
            } else {
                return;
            }

            // Check if it's the current location
            if (toAgentConfigName === agentDocsCurrentAgent && 
                (toConfigDir === fromConfigDir || (!toConfigDir && !fromConfigDir))) {
                return; // Already at this location
            }

            if (!toConfigDir) {
                alert('Invalid destination');
                return;
            }

            if (destinationValue.startsWith('agent|') && !toAgentConfigName) {
                alert('Invalid agent destination');
                return;
            }

            if (!confirm(`Move ${agentDocsCurrentFilename} to ${destinationValue.startsWith('agent|') ? 'agent docs' : 'global docs'}?`)) {
                // Reset dropdown to current location
                loadAllDestinationsForMove('agent-docs-move-destination', fromConfigDir, agentDocsCurrentAgent);
                return;
            }

            try {
                const response = await fetch(`/admin/api/docs/${encodeURIComponent(agentDocsCurrentFilename)}/move?from_config_dir=${encodeURIComponent(fromConfigDir)}&from_agent_config_name=${encodeURIComponent(agentDocsCurrentAgent)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        to_config_dir: toConfigDir,
                        to_agent_config_name: toAgentConfigName
                    })
                });

                if (response.ok) {
                    loadAgentDocs(agentDocsCurrentAgent);
                    document.getElementById('agent-docs-select').value = '';
                    document.getElementById('agent-docs-editor-container').innerHTML = '<div class="loading">Select a document to edit</div>';
                    document.getElementById('delete-agent-doc-btn').style.display = 'none';
                    agentDocsCurrentFilename = '';
                    alert('Document moved successfully');
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Move failed');
                }
            } catch (error) {
                console.error('Error moving agent doc:', error);
                alert(`Error moving document: ${error.message}`);
                // Reset dropdown to current location
                loadAllDestinationsForMove('agent-docs-move-destination', fromConfigDir, agentDocsCurrentAgent);
            }
        }
        
        // Helper functions
        // ===== Role Prompts Management Functions =====
        
        // Global prompts state
        let globalPromptsConfigDir = '';
        let globalPromptsCurrentFilename = '';
        let globalPromptsSaveTimeout = null;
        let globalPromptsFilenameTimeout = null;
        let globalPromptsContent = '';
        
        // Load config directories for global prompts
        async function loadGlobalPromptsConfigDirectories() {
            try {
                const response = await fetch('/admin/api/config-directories');
                const data = await response.json();
                
                const select = document.getElementById('global-prompts-config-select');
                if (!select) return;
                
                select.innerHTML = '<option value="">Choose a config directory...</option>';
                data.directories.forEach(dir => {
                    const option = document.createElement('option');
                    option.value = dir.path;
                    option.textContent = dir.display_path;
                    select.appendChild(option);
                });
                
                select.onchange = function() {
                    globalPromptsConfigDir = this.value;
                    // Clear the currently loaded prompt when directory changes
                    globalPromptsCurrentFilename = '';
                    globalPromptsContent = '';
                    document.getElementById('global-prompts-select').innerHTML = '<option value="">Choose a role prompt...</option>';
                    document.getElementById('global-prompts-editor-container').innerHTML = '<div class="loading">Select a config directory and role prompt to edit</div>';
                    document.getElementById('delete-global-prompt-btn').style.display = 'none';
                    // Load prompts list (will show all if no directory selected)
                    loadGlobalPromptsList();
                };
                
                // Load prompts list on initial load (will show all if no directory selected)
                loadGlobalPromptsList();
            } catch (error) {
                console.error('Error loading config directories:', error);
            }
        }
        
        // Load list of prompts for global prompts
        async function loadGlobalPromptsList() {
            try {
                // If no config directory is selected, fetch from all directories
                const url = globalPromptsConfigDir 
                    ? `/admin/api/prompts?config_dir=${encodeURIComponent(globalPromptsConfigDir)}`
                    : '/admin/api/prompts';
                
                const response = await fetch(url);
                const data = await response.json();
                
                const select = document.getElementById('global-prompts-select');
                if (!select) return;
                
                select.innerHTML = '<option value="">Choose a role prompt...</option>';
                
                // Get config directory display paths for labeling
                let configDirDisplayMap = {};
                if (!globalPromptsConfigDir) {
                    const configDirsResponse = await fetch('/admin/api/config-directories');
                    const configDirsData = await configDirsResponse.json();
                    configDirDisplayMap = {};
                    configDirsData.directories.forEach(dir => {
                        configDirDisplayMap[dir.path] = dir.display_path;
                    });
                }
                
                data.prompts.forEach(prompt => {
                    const option = document.createElement('option');
                    option.value = prompt.filename;
                    // Store config_dir in data attribute
                    option.dataset.configDir = prompt.config_dir || globalPromptsConfigDir;
                    
                    // Display filename with source directory if showing all directories
                    if (!globalPromptsConfigDir && prompt.config_dir) {
                        const displayPath = configDirDisplayMap[prompt.config_dir] || prompt.config_dir;
                        option.textContent = `${prompt.filename} (from ${displayPath})`;
                    } else {
                        option.textContent = prompt.filename;
                    }
                    select.appendChild(option);
                });
                
                select.onchange = function() {
                    if (this.value) {
                        const selectedOption = this.options[this.selectedIndex];
                        const promptConfigDir = selectedOption.dataset.configDir;
                        
                        // Always update config directory to match the selected item's directory
                        if (promptConfigDir && promptConfigDir !== globalPromptsConfigDir) {
                            const configSelect = document.getElementById('global-prompts-config-select');
                            if (configSelect) {
                                configSelect.value = promptConfigDir;
                                globalPromptsConfigDir = promptConfigDir;
                            }
                        }
                        
                        loadGlobalPrompt(this.value);
                    } else {
                        document.getElementById('global-prompts-editor-container').innerHTML = '<div class="loading">Select a role prompt to edit</div>';
                        document.getElementById('delete-global-prompt-btn').style.display = 'none';
                    }
                };
            } catch (error) {
                console.error('Error loading prompts list:', error);
            }
        }
        
        // Load a specific global prompt
        async function loadGlobalPrompt(filename) {
            if (!globalPromptsConfigDir || !filename) return;
            
            // Capture configDir at the start to avoid race conditions if dropdown changes during fetch
            const configDir = globalPromptsConfigDir;
            
            try {
                const response = await fetch(`/admin/api/prompts/${encodeURIComponent(filename)}?config_dir=${encodeURIComponent(configDir)}`);
                if (!response.ok) {
                    throw new Error('Failed to load prompt');
                }
                
                const data = await response.json();
                globalPromptsCurrentFilename = filename;
                globalPromptsContent = data.content || '';
                
                renderGlobalPromptEditor(data.content || '', filename, configDir);
                document.getElementById('delete-global-prompt-btn').style.display = 'inline-block';
            } catch (error) {
                console.error('Error loading prompt:', error);
                document.getElementById('global-prompts-editor-container').innerHTML = '<div class="error">Error loading role prompt</div>';
                globalPromptsCurrentFilename = '';
                document.getElementById('delete-global-prompt-btn').style.display = 'none';
            }
        }
        
        // Render global prompt editor
        function renderGlobalPromptEditor(content, filename, configDir) {
            const container = document.getElementById('global-prompts-editor-container');
            container.innerHTML = `
                <div style="background: white; padding: 16px; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Filename:</label>
                        <input type="text" id="global-prompts-filename" value="${escapeHtml(filename)}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;" />
                        <div id="global-prompts-filename-status" style="margin-top: 4px; font-size: 12px; color: #666;"></div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Move to:</label>
                        <select id="global-prompts-move-destination" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; width: 100%;">
                            <option value="">Move to...</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Content:</label>
                        <textarea id="global-prompts-content" style="width: 100%; min-height: 400px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 14px;">${escapeHtml(content)}</textarea>
                        <div id="global-prompts-save-status" style="margin-top: 4px; font-size: 12px; color: #666;"></div>
                    </div>
                </div>
            `;
            
            // Setup handlers
            // Capture all state at creation time to avoid race conditions
            const filenameInput = document.getElementById('global-prompts-filename');
            filenameInput.oninput = debounceGlobalPromptsFilename(configDir, filename);
            
            // Setup content change handler with auto-save
            const contentTextarea = document.getElementById('global-prompts-content');
            contentTextarea.oninput = debounceGlobalPromptsSave(configDir, filename);
            
            // Setup move destination change handler
            const moveSelect = document.getElementById('global-prompts-move-destination');
            moveSelect.onchange = function() {
                if (this.value) {
                    moveGlobalPrompt();
                }
            };
            
            // Load all destinations for move dropdown (only config directories, not agents)
            loadConfigDirectoriesForMovePrompts('global-prompts-move-destination', globalPromptsConfigDir);
        }
        
        // Debounced save for global prompts
        // Captures configDir and filename to avoid race conditions
        function debounceGlobalPromptsSave(configDir, filename) {
            return function() {
                if (globalPromptsSaveTimeout) {
                    clearTimeout(globalPromptsSaveTimeout);
                }
                
                const statusEl = document.getElementById('global-prompts-save-status');
                if (statusEl) statusEl.textContent = 'Typing...';
                
                globalPromptsSaveTimeout = setTimeout(async () => {
                    // Verify we're still editing the same prompt (user may have switched)
                    if (globalPromptsConfigDir !== configDir || globalPromptsCurrentFilename !== filename) {
                        // User switched prompts, don't save
                        if (statusEl) statusEl.textContent = '';
                        return;
                    }
                    
                    const contentTextarea = document.getElementById('global-prompts-content');
                    if (!contentTextarea) return;
                    
                    const newContent = contentTextarea.value;
                    if (newContent === globalPromptsContent) {
                        if (statusEl) statusEl.textContent = 'Saved';
                        return;
                    }
                    
                    if (statusEl) statusEl.textContent = 'Saving...';
                    
                    try {
                        // Use captured values instead of reading from globals
                        const response = await fetch(`/admin/api/prompts/${encodeURIComponent(filename)}?config_dir=${encodeURIComponent(configDir)}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ content: newContent })
                        });
                        
                        if (response.ok) {
                            globalPromptsContent = newContent;
                            if (statusEl) statusEl.textContent = 'Saved';
                        } else {
                            throw new Error('Save failed');
                        }
                    } catch (error) {
                        console.error('Error saving prompt:', error);
                        if (statusEl) statusEl.textContent = 'Error saving';
                    }
                }, 1000);
            };
        }
        
        // Immediately save any pending content changes (used before rename/move operations)
        // Returns a promise that resolves when the save is complete (or immediately if no save needed)
        async function savePendingGlobalPromptsContent(configDir, filename) {
            const contentTextarea = document.getElementById('global-prompts-content');
            if (!contentTextarea) {
                return; // No textarea, nothing to save
            }
            
            const newContent = contentTextarea.value;
            if (newContent === globalPromptsContent) {
                return; // No changes, nothing to save
            }
            
            // Verify we're still editing the same prompt (user may have switched)
            if (globalPromptsConfigDir !== configDir || globalPromptsCurrentFilename !== filename) {
                return; // User switched prompts, don't save
            }
            
            const statusEl = document.getElementById('global-prompts-save-status');
            if (statusEl) statusEl.textContent = 'Saving...';
            
            try {
                const response = await fetch(`/admin/api/prompts/${encodeURIComponent(filename)}?config_dir=${encodeURIComponent(configDir)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: newContent })
                });
                
                if (response.ok) {
                    globalPromptsContent = newContent;
                    if (statusEl) statusEl.textContent = 'Saved';
                } else {
                    throw new Error('Save failed');
                }
            } catch (error) {
                console.error('Error saving prompt:', error);
                if (statusEl) statusEl.textContent = 'Error saving';
                throw error; // Re-throw so caller knows save failed
            }
        }
        
        // Debounced filename change for global prompts
        // Captures configDir and filename to avoid race conditions
        function debounceGlobalPromptsFilename(configDir, filename) {
            return function() {
                if (globalPromptsFilenameTimeout) {
                    clearTimeout(globalPromptsFilenameTimeout);
                }
                
                const filenameInput = document.getElementById('global-prompts-filename');
                if (!filenameInput) return;
                
                const newFilename = filenameInput.value.trim();
                const statusEl = document.getElementById('global-prompts-filename-status');
                
                // Verify we're still editing the same prompt (user may have switched)
                if (globalPromptsConfigDir !== configDir || globalPromptsCurrentFilename !== filename) {
                    // User switched prompts, don't rename
                    if (statusEl) statusEl.textContent = '';
                    return;
                }
                
                if (!newFilename || newFilename === filename) {
                    if (statusEl) statusEl.textContent = '';
                    return;
                }
                
                // Validate filename format
                if (!newFilename.endsWith('.md')) {
                    if (statusEl) statusEl.textContent = 'Filename must end with .md';
                    return;
                }
                
                const nameWithoutExt = newFilename.slice(0, -3);
                if (nameWithoutExt.length > 50) {
                    if (statusEl) statusEl.textContent = 'Filename (without .md) must be 50 characters or less';
                    return;
                }
                
                if (!/^[a-zA-Z0-9_\- ]+$/.test(nameWithoutExt)) {
                    if (statusEl) statusEl.textContent = 'Filename can only contain letters, numbers, underscores, dashes, and spaces';
                    return;
                }
                
                // Ensure at least one non-space character exists (prevent filenames with only spaces)
                if (!/[a-zA-Z0-9_\-]/.test(nameWithoutExt)) {
                    if (statusEl) statusEl.textContent = 'Filename must contain at least one non-space character';
                    return;
                }
                
                if (statusEl) statusEl.textContent = 'Renaming...';
                
                globalPromptsFilenameTimeout = setTimeout(async () => {
                    // Double-check we're still editing the same prompt before renaming
                    if (globalPromptsConfigDir !== configDir || globalPromptsCurrentFilename !== filename) {
                        // User switched prompts, don't rename
                        if (statusEl) statusEl.textContent = '';
                        return;
                    }
                    
                    try {
                        // Save any pending content changes before renaming (with old filename)
                        await savePendingGlobalPromptsContent(configDir, filename);
                        
                        // Use captured values instead of reading from globals
                        const response = await fetch(`/admin/api/prompts/${encodeURIComponent(filename)}/rename?config_dir=${encodeURIComponent(configDir)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ new_filename: newFilename })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            const newFilename = data.filename;
                            
                            // Check again after fetch completes: ensure we're still editing the same prompt
                            // If user switched prompts while rename was in flight, don't update globals/handlers
                            if (globalPromptsConfigDir !== configDir || globalPromptsCurrentFilename !== filename) {
                                // User switched prompts, don't update globals or handlers
                                if (statusEl) statusEl.textContent = '';
                                return;
                            }
                            
                            globalPromptsCurrentFilename = newFilename;
                            
                            // Clear any pending save timeout to prevent saving with old filename
                            if (globalPromptsSaveTimeout) {
                                clearTimeout(globalPromptsSaveTimeout);
                                globalPromptsSaveTimeout = null;
                            }
                            
                            // Clear any pending filename timeout to prevent stale rename operations
                            if (globalPromptsFilenameTimeout) {
                                clearTimeout(globalPromptsFilenameTimeout);
                                globalPromptsFilenameTimeout = null;
                            }
                            
                            // Update handlers with new filename to allow further saves/renames
                            const contentTextarea = document.getElementById('global-prompts-content');
                            if (contentTextarea) {
                                // Update globalPromptsContent to match current textarea value
                                // (in case user continued typing during the rename operation)
                                globalPromptsContent = contentTextarea.value;
                                contentTextarea.oninput = debounceGlobalPromptsSave(configDir, newFilename);
                            }
                            const filenameInput = document.getElementById('global-prompts-filename');
                            if (filenameInput) {
                                filenameInput.oninput = debounceGlobalPromptsFilename(configDir, newFilename);
                            }

                            // Refresh the prompt list dropdown
                            loadGlobalPromptsList().then(() => {
                                document.getElementById('global-prompts-select').value = newFilename;
                            });
                            if (statusEl) statusEl.textContent = 'Renamed';
                            setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 2000);
                        } else {
                            const errorData = await response.json().catch(() => ({}));
                            throw new Error(errorData.error || 'Rename failed');
                        }
                    } catch (error) {
                        console.error('Error renaming prompt:', error);
                        if (statusEl) statusEl.textContent = `Error: ${error.message}`;
                    }
                }, 1000);
            };
        }
        
        // Create new global prompt
        async function createGlobalPrompt() {
            if (!globalPromptsConfigDir) {
                alert('Please select a config directory first');
                return;
            }

            // Find a unique filename
            let filename = 'Untitled.md';
            let counter = 1;
            try {
                // Load existing prompts to check for conflicts
                const response = await fetch(`/admin/api/prompts?config_dir=${encodeURIComponent(globalPromptsConfigDir)}`);
                const data = await response.json();
                const existingFilenames = new Set(data.prompts.map(prompt => prompt.filename));
                
                while (existingFilenames.has(filename)) {
                    filename = `Untitled-${counter}.md`;
                    counter++;
                }
            } catch (error) {
                console.error('Error checking existing prompts:', error);
                // Continue with Untitled.md, will fail if it exists
            }

            try {
                const response = await fetch(`/admin/api/prompts/${encodeURIComponent(filename)}?config_dir=${encodeURIComponent(globalPromptsConfigDir)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: '' })
                });

                if (response.ok) {
                    loadGlobalPromptsList().then(() => {
                        document.getElementById('global-prompts-select').value = filename;
                    });
                    loadGlobalPrompt(filename);
                } else {
                    throw new Error('Create failed');
                }
            } catch (error) {
                console.error('Error creating prompt:', error);
                alert('Error creating role prompt');
            }
        }
        
        // Delete global prompt
        async function deleteGlobalPrompt() {
            if (!globalPromptsCurrentFilename || !confirm(`Delete ${globalPromptsCurrentFilename}?`)) {
                return;
            }
            
            // Clear any pending save timeout to prevent saving after deletion
            if (globalPromptsSaveTimeout) {
                clearTimeout(globalPromptsSaveTimeout);
                globalPromptsSaveTimeout = null;
            }
            
            try {
                const response = await fetch(`/admin/api/prompts/${encodeURIComponent(globalPromptsCurrentFilename)}?config_dir=${encodeURIComponent(globalPromptsConfigDir)}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    loadGlobalPromptsList();
                    document.getElementById('global-prompts-select').value = '';
                    document.getElementById('global-prompts-editor-container').innerHTML = '<div class="loading">Select a role prompt to edit</div>';
                    document.getElementById('delete-global-prompt-btn').style.display = 'none';
                    globalPromptsCurrentFilename = '';
                } else {
                    throw new Error('Delete failed');
                }
            } catch (error) {
                console.error('Error deleting prompt:', error);
                alert('Error deleting role prompt');
            }
        }
        
        // Move global prompt
        async function moveGlobalPrompt() {
            if (!globalPromptsCurrentFilename) return;

            const destinationValue = document.getElementById('global-prompts-move-destination').value;
            if (!destinationValue) {
                return;
            }

            const toConfigDir = destinationValue;

            // Check if it's the current location
            if (toConfigDir === globalPromptsConfigDir) {
                return; // Already at this location
            }

            if (!toConfigDir) {
                alert('Invalid destination');
                return;
            }

            if (!confirm(`Move ${globalPromptsCurrentFilename} to ${toConfigDir}?`)) {
                // Reset dropdown to current location
                loadConfigDirectoriesForMovePrompts('global-prompts-move-destination', globalPromptsConfigDir);
                return;
            }

            // Save any pending content changes before moving
            try {
                await savePendingGlobalPromptsContent(globalPromptsConfigDir, globalPromptsCurrentFilename);
            } catch (error) {
                // If save fails, still allow move (but user may lose unsaved changes)
                console.error('Failed to save content before move:', error);
                alert('Warning: Failed to save content before move. Your recent edits may be lost.');
            }

            // Clear any pending save timeout to prevent saving after move
            if (globalPromptsSaveTimeout) {
                clearTimeout(globalPromptsSaveTimeout);
                globalPromptsSaveTimeout = null;
            }

            try {
                const response = await fetch(`/admin/api/prompts/${encodeURIComponent(globalPromptsCurrentFilename)}/move?from_config_dir=${encodeURIComponent(globalPromptsConfigDir)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        to_config_dir: toConfigDir
                    })
                });

                if (response.ok) {
                    loadGlobalPromptsList();
                    document.getElementById('global-prompts-select').value = '';
                    document.getElementById('global-prompts-editor-container').innerHTML = '<div class="loading">Select a role prompt to edit</div>';
                    document.getElementById('delete-global-prompt-btn').style.display = 'none';
                    globalPromptsCurrentFilename = '';
                    alert('Role prompt moved successfully');
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    const errorMessage = errorData.error || 'Move failed';
                    if (errorMessage.includes('already exists')) {
                        alert(`Cannot move: A role prompt with that name already exists in the destination directory.`);
                    } else {
                        alert(`Error moving role prompt: ${errorMessage}`);
                    }
                    // Reset dropdown to current location
                    loadConfigDirectoriesForMovePrompts('global-prompts-move-destination', globalPromptsConfigDir);
                }
            } catch (error) {
                console.error('Error moving prompt:', error);
                alert(`Error moving role prompt: ${error.message}`);
                // Reset dropdown to current location
                loadConfigDirectoriesForMovePrompts('global-prompts-move-destination', globalPromptsConfigDir);
            }
        }
        
        // Load config directories for move (prompts only, simpler than docs)
        async function loadConfigDirectoriesForMovePrompts(selectId, currentConfigDir) {
            try {
                const response = await fetch('/admin/api/config-directories');
                const data = await response.json();
                
                const select = document.getElementById(selectId);
                if (!select) return;
                
                select.innerHTML = '<option value="">Move to...</option>';
                data.directories.forEach(dir => {
                    const option = document.createElement('option');
                    option.value = dir.path;
                    option.textContent = dir.display_path;
                    // Mark current location
                    if (currentConfigDir === dir.path) {
                        option.selected = true;
                        option.disabled = true;
                        option.textContent += ' (current)';
                    }
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading config directories:', error);
            }
        }
        
        // Global parameters functions
        async function loadGlobalParameters() {
            const container = document.getElementById('global-parameters-container');
            container.innerHTML = '<div class="loading">Loading parameters...</div>';
            
            try {
                const response = await fetchWithAuth('/admin/api/global-parameters');
                const data = await response.json();
                
                if (data.error) {
                    container.innerHTML = `<div class="error">Error: ${escapeHtml(data.error)}</div>`;
                    return;
                }
                
                const parameters = data.parameters || [];
                
                container.innerHTML = `
                    <div style="background: white; padding: 16px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <h3 style="margin-top: 0;">Global Parameters</h3>
                        <div class="agent-param-grid">
                            ${parameters.map(param => {
                                const inputType = (param.type === 'float' || param.type === 'int') ? 'number' : 'text';
                                const stepAttr = param.type === 'float' ? 'step="0.1"' : (param.type === 'int' ? 'step="1"' : '');
                                return `
                                    <div class="agent-param-section">
                                        <h3>${escapeHtml(param.name)}</h3>
                                        <input 
                                            id="global-param-${escapeHtml(param.name)}" 
                                            type="${inputType}" 
                                            class="agent-param-input" 
                                            value="${escapeHtml(param.value)}"
                                            ${stepAttr}
                                            onchange="updateGlobalParameter('${escJsAttr(param.name)}', this.value)">
                                        <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                            ${escapeHtml(param.comment || '')}
                                            ${param.default ? ` (Default: ${escapeHtml(param.default)})` : ''}
                                        </div>
                                        <div id="global-param-status-${escapeHtml(param.name)}" style="margin-top: 4px; font-size: 12px; color: #28a745;"></div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('Error loading global parameters:', error);
                container.innerHTML = `<div class="error">Error loading parameters: ${escapeHtml(error.message || error)}</div>`;
            }
        }
        
        async function updateGlobalParameter(parameterName, value) {
            const statusEl = document.getElementById(`global-param-status-${parameterName}`);
            if (statusEl) {
                statusEl.textContent = 'Saving...';
                statusEl.style.color = '#666';
            }
            
            try {
                const response = await fetchWithAuth('/admin/api/global-parameters', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: parameterName,
                        value: value
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    if (statusEl) {
                        statusEl.textContent = `Error: ${data.error}`;
                        statusEl.style.color = '#dc3545';
                    }
                    alert(`Error updating ${parameterName}: ${data.error}`);
                } else {
                    if (statusEl) {
                        statusEl.textContent = 'Saved';
                        statusEl.style.color = '#28a745';
                    }
                }
            } catch (error) {
                console.error(`Error updating ${parameterName}:`, error);
                if (statusEl) {
                    statusEl.textContent = `Error: ${error.message || error}`;
                    statusEl.style.color = '#dc3545';
                }
                alert(`Error updating ${parameterName}: ${error.message || error}`);
            }
        }

        async function loadAllDestinationsForMove(selectId, currentConfigDir, currentAgentConfigName) {
            try {
                // Load config directories and agents in parallel
                const [configDirsResponse, agentsResponse] = await Promise.all([
                    fetch('/admin/api/config-directories'),
                    fetchWithAuth(`${API_BASE}/agents`)
                ]);
                
                const configDirsData = await configDirsResponse.json();
                const agentsData = await agentsResponse.json();
                
                const select = document.getElementById(selectId);
                if (!select) return;
                
                select.innerHTML = '<option value="">Move to...</option>';
                
                // Add global config directories
                configDirsData.directories.forEach(dir => {
                    const option = document.createElement('option');
                    option.value = `global|${dir.path}`;
                    option.textContent = `Global: ${dir.display_path}`;
                    // Mark current location if it's a global doc
                    if (currentConfigDir === dir.path && !currentAgentConfigName) {
                        option.selected = true;
                        option.disabled = true;
                        option.textContent += ' (current)';
                    }
                    select.appendChild(option);
                });
                
                // Add agents
                agentsData.agents.forEach(agent => {
                    const option = document.createElement('option');
                    const agentConfigDir = agent.config_directory || '';
                    option.value = `agent|${agentConfigDir}|${agent.config_name}`;
                    const displayName = agentConfigDir ? 
                        `Agent: ${agent.name} (${agentConfigDir})` : 
                        `Agent: ${agent.name}`;
                    option.textContent = displayName;
                    // Mark current location if it's this agent's doc
                    const currentConfigDirNormalized = currentConfigDir || '';
                    const agentConfigDirNormalized = agentConfigDir || '';
                    if (currentAgentConfigName === agent.config_name && 
                        currentConfigDirNormalized === agentConfigDirNormalized) {
                        option.selected = true;
                        option.disabled = true;
                        option.textContent += ' (current)';
                    }
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading destinations:', error);
            }
        }
        
        async function loadConfigDirectoriesForMove(selectId) {
            try {
                const response = await fetch('/admin/api/config-directories');
                const data = await response.json();
                
                const select = document.getElementById(selectId);
                if (!select) return;
                
                select.innerHTML = '<option value="">Select config directory...</option>';
                data.directories.forEach(dir => {
                    const option = document.createElement('option');
                    option.value = dir.path;
                    option.textContent = dir.display_path;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading config directories:', error);
            }
        }
        
        async function loadAgentsForMove(selectId) {
            try {
                const response = await fetchWithAuth(`${API_BASE}/agents`);
                const data = await response.json();
                
                const select = document.getElementById(selectId);
                if (!select) return;
                
                select.innerHTML = '<option value="">Select agent...</option>';
                data.agents.forEach(agent => {
                    const option = document.createElement('option');
                    option.value = agent.config_name;
                    option.textContent = agent.name;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading agents:', error);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function escJsAttr(str) {
            if (!str) return '';
            return str.replace(/\\/g, '\\\\')
                      .replace(/\n/g, '\\n')
                      .replace(/\r/g, '\\r')
                      .replace(/'/g, "\\'")
                      .replace(/"/g, '&quot;')
                      .replace(/`/g, '\\`');
        }

        function escJsTemplate(str) {
            if (!str) return '';
            return str.replace(/\\/g, '\\\\')
                      .replace(/`/g, '\\`')
                      .replace(/\$/g, '\\$');
        }
        
        // Ensure subtab bars are visible for active tab panels on page load
        document.addEventListener('DOMContentLoaded', function() {
            const activePanel = document.querySelector('.tab-panel.active');
            if (activePanel) {
                const subtabBar = activePanel.querySelector('.tab-bar');
                if (subtabBar) {
                    subtabBar.style.display = 'flex';
                    subtabBar.style.visibility = 'visible';
                    subtabBar.style.opacity = '1';
                }
            }
        });
    </script>
</body>
</html>
